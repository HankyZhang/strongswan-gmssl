# strongSwan 国密插件 (gmsm) 开发指南

> 📅 创建日期: 2025-10-30  
> 🎯 目标: 在 strongSwan 中实现完整的国密算法支持 (SM2/SM3/SM4)

---

## 📋 目录

- [1. 当前状态](#1-当前状态)
- [2. 插件架构分析](#2-插件架构分析)
- [3. gmsm 插件设计](#3-gmsm-插件设计)
- [4. 实施步骤](#4-实施步骤)
- [5. 文件清单](#5-文件清单)
- [6. 测试验证](#6-测试验证)

---

## 1. 当前状态

### ✅ 已完成
- [x] GmSSL 3.1.1 库集成脚本
- [x] Docker 镜像构建配置
- [x] 国密算法配置文件 (swanctl-gmssl.conf)
- [x] 部署自动化脚本
- [x] 完整文档

### ❌ 缺失组件
- [ ] **gmsm 插件** - strongSwan 不包含此插件，需要开发
- [ ] SM2 密钥交换实现
- [ ] SM3 哈希算法接口
- [ ] SM4 加密算法接口

### ⚠️ 问题
配置文件引用了不存在的算法提案：
```
proposals = sm4cbc-sm3-sm2                  # ❌ strongSwan 不识别
esp_proposals = sm4gcm128-sm3-modp2048      # ❌ strongSwan 不识别
```

**结论**: 需要开发 `gmsm` 插件才能使用国密算法。

---

## 2. 插件架构分析

### 2.1 strongSwan 插件系统

strongSwan 使用模块化插件架构，插件位于：
```
src/libstrongswan/plugins/<plugin_name>/
```

### 2.2 参考插件：`gmp` 插件

**目录结构**:
```
src/libstrongswan/plugins/gmp/
├── Makefile.am                      # 构建配置
├── gmp_plugin.h                     # 插件头文件
├── gmp_plugin.c                     # 插件注册和特性声明
├── gmp_diffie_hellman.h             # DH 密钥交换头文件
├── gmp_diffie_hellman.c             # DH 密钥交换实现
├── gmp_rsa_private_key.h            # RSA 私钥头文件
├── gmp_rsa_private_key.c            # RSA 私钥实现
├── gmp_rsa_public_key.h             # RSA 公钥头文件
└── gmp_rsa_public_key.c             # RSA 公钥实现
```

**插件特性声明** (gmp_plugin.c):
```c
METHOD(plugin_t, get_features, int,
    private_gmp_plugin_t *this, plugin_feature_t *features[])
{
    static plugin_feature_t f[] = {
        // 密钥交换
        PLUGIN_REGISTER(KE, gmp_diffie_hellman_create),
            PLUGIN_PROVIDE(KE, MODP_2048_BIT),
                PLUGIN_DEPENDS(RNG, RNG_STRONG),
        
        // 私钥
        PLUGIN_REGISTER(PRIVKEY, gmp_rsa_private_key_load, TRUE),
            PLUGIN_PROVIDE(PRIVKEY, KEY_RSA),
        
        // 签名方案
        PLUGIN_PROVIDE(PRIVKEY_SIGN, SIGN_RSA_EMSA_PKCS1_SHA256),
    };
    *features = f;
    return countof(f);
}
```

### 2.3 参考插件：`openssl` 插件

**提供的功能**:
- 对称加密: AES, DES, Blowfish
- 哈希算法: SHA1, SHA2, SHA3, MD5
- 非对称加密: RSA, ECDSA
- 密钥交换: DH, ECDH

**关键文件**:
```
src/libstrongswan/plugins/openssl/
├── openssl_plugin.c                 # 插件注册
├── openssl_crypter.c                # 对称加密
├── openssl_hasher.c                 # 哈希算法
├── openssl_ec_private_key.c         # ECC 私钥
├── openssl_ec_public_key.c          # ECC 公钥
└── openssl_diffie_hellman.c         # DH 密钥交换
```

---

## 3. gmsm 插件设计

### 3.1 目标

创建 `gmsm` 插件，提供以下国密算法支持：

| 算法 | 类型 | strongSwan 类别 | GmSSL API |
|------|------|----------------|-----------|
| **SM2** | 非对称加密/签名 | PRIVKEY, PUBKEY, KE | `SM2_KEY`, `SM2_sign`, `SM2_verify` |
| **SM3** | 哈希算法 | HASHER | `sm3_init`, `sm3_update`, `sm3_finish` |
| **SM4** | 对称加密 | CRYPTER | `sm4_set_encrypt_key`, `sm4_cbc_encrypt` |

### 3.2 目录结构

```
src/libstrongswan/plugins/gmsm/
├── Makefile.am                      # 构建配置
├── gmsm_plugin.h                    # 插件头文件
├── gmsm_plugin.c                    # 插件注册和特性声明
├── gmsm_sm3_hasher.h                # SM3 哈希头文件
├── gmsm_sm3_hasher.c                # SM3 哈希实现
├── gmsm_sm4_crypter.h               # SM4 加密头文件
├── gmsm_sm4_crypter.c               # SM4 加密实现
├── gmsm_sm2_private_key.h           # SM2 私钥头文件
├── gmsm_sm2_private_key.c           # SM2 私钥实现
├── gmsm_sm2_public_key.h            # SM2 公钥头文件
├── gmsm_sm2_public_key.c            # SM2 公钥实现
└── gmsm_sm2_diffie_hellman.h        # SM2 密钥交换头文件
    gmsm_sm2_diffie_hellman.c        # SM2 密钥交换实现
```

### 3.3 核心数据结构

#### 3.3.1 SM3 哈希器

```c
typedef struct private_gmsm_sm3_hasher_t private_gmsm_sm3_hasher_t;

struct private_gmsm_sm3_hasher_t {
    hasher_t public;              // strongSwan 接口
    SM3_CTX ctx;                  // GmSSL SM3 上下文
};
```

#### 3.3.2 SM4 加密器

```c
typedef struct private_gmsm_sm4_crypter_t private_gmsm_sm4_crypter_t;

struct private_gmsm_sm4_crypter_t {
    crypter_t public;             // strongSwan 接口
    SM4_KEY key;                  // GmSSL SM4 密钥
    uint8_t iv[16];               // CBC 模式 IV
};
```

#### 3.3.3 SM2 私钥

```c
typedef struct private_gmsm_sm2_private_key_t private_gmsm_sm2_private_key_t;

struct private_gmsm_sm2_private_key_t {
    private_key_t public;         // strongSwan 接口
    SM2_KEY key;                  // GmSSL SM2 密钥
    refcount_t ref;               // 引用计数
};
```

### 3.4 算法标识符扩展

需要在 strongSwan 核心枚举中添加国密算法标识符：

**文件**: `src/libstrongswan/crypto/hashers/hasher.h`
```c
enum hash_algorithm_t {
    HASH_UNKNOWN,
    HASH_MD2,
    // ...
    HASH_SHA3_512,
    HASH_SM3,          // ← 新增
};
```

**文件**: `src/libstrongswan/crypto/crypters/crypter.h`
```c
enum encryption_algorithm_t {
    ENCR_UNDEFINED,
    ENCR_DES_IV64,
    // ...
    ENCR_AES_GCM_16,
    ENCR_SM4_CBC,      // ← 新增
    ENCR_SM4_GCM,      // ← 新增
};
```

**文件**: `src/libstrongswan/credentials/keys/public_key.h`
```c
enum key_type_t {
    KEY_ANY,
    KEY_RSA,
    KEY_ECDSA,
    KEY_DSA,
    KEY_ED25519,
    KEY_ED448,
    KEY_BLISS,
    KEY_SM2,          // ← 新增
};

enum signature_scheme_t {
    SIGN_UNKNOWN,
    SIGN_RSA_EMSA_PKCS1_NULL,
    // ...
    SIGN_ECDSA_521,
    SIGN_SM2_SM3,     // ← 新增
};
```

### 3.5 IKEv2 算法提案扩展

**文件**: `src/libcharon/config/proposal.h`

需要添加国密算法到提案解析器：

```c
// IKE 加密算法
{ ENCR_SM4_CBC, "sm4cbc" },
{ ENCR_SM4_CBC, "sm4" },
{ ENCR_SM4_GCM_16, "sm4gcm128" },

// IKE 完整性算法
{ AUTH_HMAC_SM3_256, "sm3" },

// IKE 密钥交换
{ SM2, "sm2" },
```

---

## 4. 实施步骤

### 阶段 1: 准备工作（1天）

#### 1.1 创建插件目录结构
```bash
mkdir -p src/libstrongswan/plugins/gmsm
cd src/libstrongswan/plugins/gmsm
```

#### 1.2 创建 Makefile.am
```makefile
AM_CPPFLAGS = \
    -I$(top_srcdir)/src/libstrongswan \
    -I/usr/local/include/gmssl

AM_CFLAGS = \
    $(PLUGIN_CFLAGS)

if MONOLITHIC
noinst_LTLIBRARIES = libstrongswan-gmsm.la
else
plugin_LTLIBRARIES = libstrongswan-gmsm.la
endif

libstrongswan_gmsm_la_SOURCES = \
    gmsm_plugin.h gmsm_plugin.c \
    gmsm_sm3_hasher.h gmsm_sm3_hasher.c \
    gmsm_sm4_crypter.h gmsm_sm4_crypter.c \
    gmsm_sm2_private_key.h gmsm_sm2_private_key.c \
    gmsm_sm2_public_key.h gmsm_sm2_public_key.c

libstrongswan_gmsm_la_LDFLAGS = -module -avoid-version
libstrongswan_gmsm_la_LIBADD = -lgmssl
```

#### 1.3 修改 configure.ac
在 `configure.ac` 中添加：
```bash
ARG_ENABL_SET([gmsm], [enable Chinese SM2/SM3/SM4 crypto plugin (GmSSL).])
```

在输出部分添加：
```bash
m4_include(m4/macros/add-plugin.m4)
ADD_PLUGIN([gmsm], [s charon nm cmd])
```

### 阶段 2: SM3 哈希算法实现（1天）

#### 2.1 创建 gmsm_sm3_hasher.h

```c
#ifndef GMSM_SM3_HASHER_H_
#define GMSM_SM3_HASHER_H_

#include <crypto/hashers/hasher.h>

typedef struct gmsm_sm3_hasher_t gmsm_sm3_hasher_t;

struct gmsm_sm3_hasher_t {
    hasher_t hasher;
};

gmsm_sm3_hasher_t *gmsm_sm3_hasher_create(hash_algorithm_t algo);

#endif
```

#### 2.2 创建 gmsm_sm3_hasher.c

```c
#include "gmsm_sm3_hasher.h"
#include <gmssl/sm3.h>

typedef struct private_gmsm_sm3_hasher_t private_gmsm_sm3_hasher_t;

struct private_gmsm_sm3_hasher_t {
    gmsm_sm3_hasher_t public;
    SM3_CTX ctx;
};

METHOD(hasher_t, reset, bool,
    private_gmsm_sm3_hasher_t *this)
{
    sm3_init(&this->ctx);
    return TRUE;
}

METHOD(hasher_t, get_hash, bool,
    private_gmsm_sm3_hasher_t *this, chunk_t chunk, uint8_t *hash)
{
    sm3_update(&this->ctx, chunk.ptr, chunk.len);
    if (hash) {
        sm3_finish(&this->ctx, hash);
        sm3_init(&this->ctx);
    }
    return TRUE;
}

METHOD(hasher_t, allocate_hash, bool,
    private_gmsm_sm3_hasher_t *this, chunk_t chunk, chunk_t *hash)
{
    if (hash) {
        *hash = chunk_alloc(32);  // SM3 输出 256 位
        get_hash(this, chunk, hash->ptr);
    } else {
        get_hash(this, chunk, NULL);
    }
    return TRUE;
}

METHOD(hasher_t, get_hash_size, size_t,
    private_gmsm_sm3_hasher_t *this)
{
    return 32;  // SM3 输出 256 位
}

METHOD(hasher_t, destroy, void,
    private_gmsm_sm3_hasher_t *this)
{
    memwipe(&this->ctx, sizeof(SM3_CTX));
    free(this);
}

gmsm_sm3_hasher_t *gmsm_sm3_hasher_create(hash_algorithm_t algo)
{
    private_gmsm_sm3_hasher_t *this;

    if (algo != HASH_SM3) {
        return NULL;
    }

    INIT(this,
        .public = {
            .hasher = {
                .reset = _reset,
                .get_hash = _get_hash,
                .allocate_hash = _allocate_hash,
                .get_hash_size = _get_hash_size,
                .destroy = _destroy,
            },
        },
    );

    sm3_init(&this->ctx);
    return &this->public;
}
```

### 阶段 3: SM4 对称加密实现（1-2天）

#### 3.1 创建 gmsm_sm4_crypter.h

```c
#ifndef GMSM_SM4_CRYPTER_H_
#define GMSM_SM4_CRYPTER_H_

#include <crypto/crypters/crypter.h>

typedef struct gmsm_sm4_crypter_t gmsm_sm4_crypter_t;

struct gmsm_sm4_crypter_t {
    crypter_t crypter;
};

gmsm_sm4_crypter_t *gmsm_sm4_crypter_create(
    encryption_algorithm_t algo, size_t key_size);

#endif
```

#### 3.2 创建 gmsm_sm4_crypter.c

```c
#include "gmsm_sm4_crypter.h"
#include <gmssl/sm4.h>

#define SM4_BLOCK_SIZE 16
#define SM4_KEY_SIZE 16

typedef struct private_gmsm_sm4_crypter_t private_gmsm_sm4_crypter_t;

struct private_gmsm_sm4_crypter_t {
    gmsm_sm4_crypter_t public;
    SM4_KEY encrypt_key;
    SM4_KEY decrypt_key;
    encryption_algorithm_t algo;
};

METHOD(crypter_t, encrypt, bool,
    private_gmsm_sm4_crypter_t *this, chunk_t data, chunk_t iv,
    chunk_t *encrypted)
{
    uint8_t *in, *out;
    
    if (encrypted) {
        *encrypted = chunk_alloc(data.len);
        out = encrypted->ptr;
    } else {
        out = data.ptr;
    }
    in = data.ptr;

    switch (this->algo) {
        case ENCR_SM4_CBC:
            sm4_cbc_encrypt(&this->encrypt_key, iv.ptr, 
                           in, data.len / SM4_BLOCK_SIZE, out);
            break;
        case ENCR_SM4_GCM:
            // TODO: 实现 SM4-GCM
            return FALSE;
        default:
            return FALSE;
    }
    return TRUE;
}

METHOD(crypter_t, decrypt, bool,
    private_gmsm_sm4_crypter_t *this, chunk_t data, chunk_t iv,
    chunk_t *decrypted)
{
    uint8_t *in, *out;
    
    if (decrypted) {
        *decrypted = chunk_alloc(data.len);
        out = decrypted->ptr;
    } else {
        out = data.ptr;
    }
    in = data.ptr;

    switch (this->algo) {
        case ENCR_SM4_CBC:
            sm4_cbc_decrypt(&this->decrypt_key, iv.ptr,
                           in, data.len / SM4_BLOCK_SIZE, out);
            break;
        case ENCR_SM4_GCM:
            // TODO: 实现 SM4-GCM
            return FALSE;
        default:
            return FALSE;
    }
    return TRUE;
}

METHOD(crypter_t, get_block_size, size_t,
    private_gmsm_sm4_crypter_t *this)
{
    return SM4_BLOCK_SIZE;
}

METHOD(crypter_t, get_iv_size, size_t,
    private_gmsm_sm4_crypter_t *this)
{
    return SM4_BLOCK_SIZE;
}

METHOD(crypter_t, get_key_size, size_t,
    private_gmsm_sm4_crypter_t *this)
{
    return SM4_KEY_SIZE;
}

METHOD(crypter_t, set_key, bool,
    private_gmsm_sm4_crypter_t *this, chunk_t key)
{
    if (key.len != SM4_KEY_SIZE) {
        return FALSE;
    }
    
    sm4_set_encrypt_key(&this->encrypt_key, key.ptr);
    sm4_set_decrypt_key(&this->decrypt_key, key.ptr);
    return TRUE;
}

METHOD(crypter_t, destroy, void,
    private_gmsm_sm4_crypter_t *this)
{
    memwipe(&this->encrypt_key, sizeof(SM4_KEY));
    memwipe(&this->decrypt_key, sizeof(SM4_KEY));
    free(this);
}

gmsm_sm4_crypter_t *gmsm_sm4_crypter_create(
    encryption_algorithm_t algo, size_t key_size)
{
    private_gmsm_sm4_crypter_t *this;

    if (key_size != SM4_KEY_SIZE) {
        return NULL;
    }
    if (algo != ENCR_SM4_CBC && algo != ENCR_SM4_GCM) {
        return NULL;
    }

    INIT(this,
        .public = {
            .crypter = {
                .encrypt = _encrypt,
                .decrypt = _decrypt,
                .get_block_size = _get_block_size,
                .get_iv_size = _get_iv_size,
                .get_key_size = _get_key_size,
                .set_key = _set_key,
                .destroy = _destroy,
            },
        },
        .algo = algo,
    );

    return &this->public;
}
```

### 阶段 4: SM2 非对称加密实现（2-3天）

#### 4.1 创建 gmsm_sm2_private_key.h

```c
#ifndef GMSM_SM2_PRIVATE_KEY_H_
#define GMSM_SM2_PRIVATE_KEY_H_

#include <credentials/builder.h>
#include <credentials/keys/private_key.h>

typedef struct gmsm_sm2_private_key_t gmsm_sm2_private_key_t;

struct gmsm_sm2_private_key_t {
    private_key_t key;
};

gmsm_sm2_private_key_t *gmsm_sm2_private_key_gen(
    key_type_t type, va_list args);

gmsm_sm2_private_key_t *gmsm_sm2_private_key_load(
    key_type_t type, va_list args);

#endif
```

#### 4.2 创建 gmsm_sm2_private_key.c

```c
#include "gmsm_sm2_private_key.h"
#include <gmssl/sm2.h>

typedef struct private_gmsm_sm2_private_key_t private_gmsm_sm2_private_key_t;

struct private_gmsm_sm2_private_key_t {
    gmsm_sm2_private_key_t public;
    SM2_KEY key;
    refcount_t ref;
};

METHOD(private_key_t, sign, bool,
    private_gmsm_sm2_private_key_t *this, signature_scheme_t scheme,
    void *params, chunk_t data, chunk_t *signature)
{
    uint8_t sig[SM2_MAX_SIGNATURE_SIZE];
    size_t siglen;

    if (scheme != SIGN_SM2_SM3) {
        return FALSE;
    }

    if (sm2_sign(&this->key, data.ptr, data.len, sig, &siglen) != 1) {
        return FALSE;
    }

    *signature = chunk_clone(chunk_create(sig, siglen));
    return TRUE;
}

METHOD(private_key_t, get_type, key_type_t,
    private_gmsm_sm2_private_key_t *this)
{
    return KEY_SM2;
}

METHOD(private_key_t, get_keysize, int,
    private_gmsm_sm2_private_key_t *this)
{
    return 256;  // SM2 使用 256 位密钥
}

METHOD(private_key_t, get_public_key, public_key_t*,
    private_gmsm_sm2_private_key_t *this)
{
    // TODO: 从私钥提取公钥
    return NULL;
}

METHOD(private_key_t, get_ref, private_key_t*,
    private_gmsm_sm2_private_key_t *this)
{
    ref_get(&this->ref);
    return &this->public.key;
}

METHOD(private_key_t, destroy, void,
    private_gmsm_sm2_private_key_t *this)
{
    if (ref_put(&this->ref)) {
        memwipe(&this->key, sizeof(SM2_KEY));
        free(this);
    }
}

gmsm_sm2_private_key_t *gmsm_sm2_private_key_gen(
    key_type_t type, va_list args)
{
    private_gmsm_sm2_private_key_t *this;

    if (type != KEY_SM2) {
        return NULL;
    }

    INIT(this,
        .public = {
            .key = {
                .sign = _sign,
                .get_type = _get_type,
                .get_keysize = _get_keysize,
                .get_public_key = _get_public_key,
                .get_ref = _get_ref,
                .destroy = _destroy,
            },
        },
        .ref = 1,
    );

    // 生成 SM2 密钥对
    if (sm2_key_generate(&this->key) != 1) {
        destroy(this);
        return NULL;
    }

    return &this->public;
}

gmsm_sm2_private_key_t *gmsm_sm2_private_key_load(
    key_type_t type, va_list args)
{
    // TODO: 从 PEM/DER 加载私钥
    return NULL;
}
```

### 阶段 5: 插件注册（1天）

#### 5.1 创建 gmsm_plugin.h

```c
#ifndef GMSM_PLUGIN_H_
#define GMSM_PLUGIN_H_

#include <plugins/plugin.h>

typedef struct gmsm_plugin_t gmsm_plugin_t;

struct gmsm_plugin_t {
    plugin_t plugin;
};

#endif
```

#### 5.2 创建 gmsm_plugin.c

```c
#include "gmsm_plugin.h"
#include "gmsm_sm3_hasher.h"
#include "gmsm_sm4_crypter.h"
#include "gmsm_sm2_private_key.h"
#include "gmsm_sm2_public_key.h"

#include <library.h>

typedef struct private_gmsm_plugin_t private_gmsm_plugin_t;

struct private_gmsm_plugin_t {
    gmsm_plugin_t public;
};

METHOD(plugin_t, get_name, char*,
    private_gmsm_plugin_t *this)
{
    return "gmsm";
}

METHOD(plugin_t, get_features, int,
    private_gmsm_plugin_t *this, plugin_feature_t *features[])
{
    static plugin_feature_t f[] = {
        /* SM3 哈希算法 */
        PLUGIN_REGISTER(HASHER, gmsm_sm3_hasher_create),
            PLUGIN_PROVIDE(HASHER, HASH_SM3),
        
        /* SM4 对称加密 */
        PLUGIN_REGISTER(CRYPTER, gmsm_sm4_crypter_create),
            PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_CBC, 16),
            PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_GCM, 16),
        
        /* SM2 私钥 */
        PLUGIN_REGISTER(PRIVKEY, gmsm_sm2_private_key_load, TRUE),
            PLUGIN_PROVIDE(PRIVKEY, KEY_SM2),
        PLUGIN_REGISTER(PRIVKEY_GEN, gmsm_sm2_private_key_gen, FALSE),
            PLUGIN_PROVIDE(PRIVKEY_GEN, KEY_SM2),
                PLUGIN_DEPENDS(RNG, RNG_TRUE),
        
        /* SM2 公钥 */
        PLUGIN_REGISTER(PUBKEY, gmsm_sm2_public_key_load, TRUE),
            PLUGIN_PROVIDE(PUBKEY, KEY_SM2),
        
        /* SM2 签名方案 */
        PLUGIN_PROVIDE(PRIVKEY_SIGN, SIGN_SM2_SM3),
            PLUGIN_SDEPEND(HASHER, HASH_SM3),
        PLUGIN_PROVIDE(PUBKEY_VERIFY, SIGN_SM2_SM3),
            PLUGIN_SDEPEND(HASHER, HASH_SM3),
    };
    
    *features = f;
    return countof(f);
}

METHOD(plugin_t, destroy, void,
    private_gmsm_plugin_t *this)
{
    free(this);
}

plugin_t *gmsm_plugin_create()
{
    private_gmsm_plugin_t *this;

    INIT(this,
        .public = {
            .plugin = {
                .get_name = _get_name,
                .get_features = _get_features,
                .destroy = _destroy,
            },
        },
    );

    return &this->public.plugin;
}
```

### 阶段 6: 核心枚举扩展（1天）

需要修改以下文件添加国密算法标识符：

#### 6.1 哈希算法
**文件**: `src/libstrongswan/crypto/hashers/hasher.h`

在 `enum hash_algorithm_t` 添加：
```c
HASH_SM3 = 256,  // 使用未占用的编号
```

在 `hash_algorithm_names` 数组添加：
```c
{ HASH_SM3, "HASH_SM3" },
```

#### 6.2 对称加密算法
**文件**: `src/libstrongswan/crypto/crypters/crypter.h`

在 `enum encryption_algorithm_t` 添加：
```c
ENCR_SM4_CBC = 256,
ENCR_SM4_GCM = 257,
```

#### 6.3 非对称密钥类型
**文件**: `src/libstrongswan/credentials/keys/public_key.h`

在 `enum key_type_t` 添加：
```c
KEY_SM2 = 256,
```

在 `enum signature_scheme_t` 添加：
```c
SIGN_SM2_SM3 = 256,
```

#### 6.4 IKE 提案解析
**文件**: `src/libcharon/config/proposal.c`

在算法提案解析器中添加国密算法映射：

```c
// 加密算法
{ ENCR_SM4_CBC, "sm4cbc" },
{ ENCR_SM4_CBC, "sm4" },
{ ENCR_SM4_GCM_16, "sm4gcm128" },
{ ENCR_SM4_GCM_16, "sm4gcm" },

// 完整性算法
{ AUTH_HMAC_SM3_256, "sm3" },
{ AUTH_HMAC_SM3_256, "hmac_sm3" },

// 密钥交换 (需要在 key_exchange.h 中添加 SM2)
{ SM2, "sm2" },
```

### 阶段 7: 配置和构建（1天）

#### 7.1 修改 configure.ac

在 cryptographic plugins 部分添加：
```bash
ARG_ENABL_SET([gmsm],           [enable Chinese SM2/SM3/SM4 crypto plugin (GmSSL).])
```

#### 7.2 修改 src/libstrongswan/plugins/Makefile.am

添加 gmsm 子目录：
```makefile
if USE_GMSM
  SUBDIRS += gmsm
endif
```

#### 7.3 构建测试

```bash
./autogen.sh
./configure --prefix=/usr/local/strongswan --sysconfdir=/etc \
    --enable-gmsm \
    --with-gmssl=/usr/local \
    --enable-openssl \
    --enable-swanctl --enable-vici \
    --disable-gmp

make -j $(nproc)
sudo make install
```

### 阶段 8: 测试验证（1-2天）

#### 8.1 单元测试

创建 `src/libstrongswan/tests/suites/test_gmsm.c`:

```c
#include <tests/test_suite.h>
#include <plugins/gmsm/gmsm_sm3_hasher.h>

START_TEST(test_sm3_hash)
{
    hasher_t *hasher;
    chunk_t data = chunk_from_str("abc");
    chunk_t hash;
    
    hasher = (hasher_t*)gmsm_sm3_hasher_create(HASH_SM3);
    ck_assert(hasher != NULL);
    
    ck_assert(hasher->allocate_hash(hasher, data, &hash));
    ck_assert_int_eq(hash.len, 32);
    
    chunk_free(&hash);
    hasher->destroy(hasher);
}
END_TEST

Suite *gmsm_suite_create()
{
    Suite *s;
    TCase *tc;
    
    s = suite_create("gmsm");
    
    tc = tcase_create("sm3");
    tcase_add_test(tc, test_sm3_hash);
    suite_add_tcase(s, tc);
    
    return s;
}
```

运行测试：
```bash
make check
```

#### 8.2 集成测试

创建测试配置 `test-gmsm.conf`:

```
connections {
    test-sm2-sm3-sm4 {
        version = 2
        proposals = sm4cbc-sm3-sm2
        local {
            auth = pubkey
            certs = local-cert.pem
            id = local@strongswan.org
        }
        remote {
            auth = pubkey
            id = remote@strongswan.org
        }
        children {
            net {
                esp_proposals = sm4gcm128-sm3
                local_ts = 10.1.0.0/24
                remote_ts = 10.2.0.0/24
            }
        }
    }
}
```

启动测试：
```bash
sudo swanctl --load-all -f test-gmsm.conf
sudo swanctl --initiate --child net
sudo swanctl --list-sas
```

预期输出：
```
test-sm2-sm3-sm4: #1, ESTABLISHED, IKEv2, SM2_SM3
  local  'local@strongswan.org' @ 10.1.0.1
  remote 'remote@strongswan.org' @ 10.2.0.1
  AES_CBC_128/HMAC_SHA2_256/PRF_HMAC_SHA2_256/SM2_256
  established 1s ago, reauth in 3600s
  net: #1, reqid 1, INSTALLED, TUNNEL, ESP:SM4_GCM_16/SM3
    installed 1s ago, rekeying in 2700s
    in  c8f24e3a, 0 bytes, 0 packets
    out 5d91f0a1, 0 bytes, 0 packets
    local  10.1.0.0/24
    remote 10.2.0.0/24
```

---

## 5. 文件清单

### 5.1 新增文件

```
src/libstrongswan/plugins/gmsm/
├── Makefile.am                      ✅ 构建配置
├── gmsm_plugin.h                    ✅ 插件头文件
├── gmsm_plugin.c                    ✅ 插件实现
├── gmsm_sm3_hasher.h                ✅ SM3 头文件
├── gmsm_sm3_hasher.c                ✅ SM3 实现
├── gmsm_sm4_crypter.h               ✅ SM4 头文件
├── gmsm_sm4_crypter.c               ✅ SM4 实现
├── gmsm_sm2_private_key.h           ✅ SM2 私钥头文件
├── gmsm_sm2_private_key.c           ✅ SM2 私钥实现
├── gmsm_sm2_public_key.h            ✅ SM2 公钥头文件
└── gmsm_sm2_public_key.c            ✅ SM2 公钥实现

src/libstrongswan/tests/suites/
└── test_gmsm.c                      ✅ 单元测试
```

### 5.2 修改文件

```
configure.ac                                    ← 添加 --enable-gmsm 选项
src/libstrongswan/plugins/Makefile.am          ← 添加 gmsm 子目录
src/libstrongswan/crypto/hashers/hasher.h      ← 添加 HASH_SM3
src/libstrongswan/crypto/crypters/crypter.h    ← 添加 ENCR_SM4_CBC/GCM
src/libstrongswan/credentials/keys/public_key.h ← 添加 KEY_SM2, SIGN_SM2_SM3
src/libcharon/config/proposal.c                ← 添加算法名称映射
```

---

## 6. 测试验证

### 6.1 编译验证

```bash
# 1. 清理旧构建
make clean

# 2. 重新配置
./configure --enable-gmsm --with-gmssl=/usr/local

# 3. 编译
make -j $(nproc)

# 4. 检查插件是否编译成功
ls -la src/libstrongswan/plugins/gmsm/.libs/
# 应该看到: libstrongswan-gmsm.so
```

### 6.2 运行时验证

```bash
# 1. 安装
sudo make install

# 2. 检查插件是否加载
sudo ipsec start
sudo ipsec statusall | grep gmsm
# 应该看到: gmsm plugin loaded

# 3. 列出支持的算法
sudo ipsec listall
# 应该看到:
#   Encryption: SM4_CBC, SM4_GCM
#   Integrity: HMAC_SM3
#   Key Exchange: SM2
#   Signature: SM2_SM3
```

### 6.3 功能验证

**SM3 哈希测试**:
```bash
echo -n "abc" | openssl dgst -sm3
# 66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0

# 与 strongSwan 内部实现对比
```

**SM4 加密测试**:
```bash
# 生成测试密钥
echo "0123456789ABCDEF" > test.key

# 测试数据
echo "Hello, SM4!" > plain.txt

# 使用 GmSSL 加密
gmssl sm4 -e -in plain.txt -out cipher.bin -key test.key

# 使用 strongSwan 解密 (通过 VPN 隧道验证)
```

**SM2 签名测试**:
```bash
# 生成 SM2 密钥对
gmssl genpkey -algorithm SM2 -out sm2-private.pem
gmssl pkey -in sm2-private.pem -pubout -out sm2-public.pem

# 使用 strongSwan 加载证书并建立连接
sudo swanctl --load-creds
```

### 6.4 VPN 隧道测试

**配置文件**: `swanctl-gmssl.conf`

```bash
connections {
    gm-tunnel {
        version = 2
        proposals = sm4cbc-sm3-sm2
        
        local {
            auth = psk
            id = local-gm
        }
        remote {
            auth = psk
            id = remote-gm
        }
        children {
            net {
                esp_proposals = sm4gcm128-sm3
                local_ts = 10.1.0.0/24
                remote_ts = 10.2.0.0/24
            }
        }
    }
}

secrets {
    ike-gm {
        id = local-gm
        secret = "MyStrongPSK2024!@#SecureVPN"
    }
}
```

**启动连接**:
```bash
sudo swanctl --load-all
sudo swanctl --initiate --child net
sudo swanctl --list-sas
```

**预期输出**:
```
gm-tunnel: #1, ESTABLISHED, IKEv2, SM2_SM3
  local  'local-gm' @ 10.1.0.1[500]
  remote 'remote-gm' @ 10.2.0.1[500]
  SM4_CBC_128/HMAC_SM3_256/PRF_HMAC_SM3_256/SM2_256
  established 5s ago, reauth in 3595s
  net: #1, reqid 1, INSTALLED, TUNNEL, ESP:SM4_GCM_128/SM3
    installed 5s ago, rekeying in 2695s
    in  c8f24e3a,  1024 bytes,  16 packets
    out 5d91f0a1,  2048 bytes,  32 packets
    local  10.1.0.0/24
    remote 10.2.0.0/24
```

---

## 7. 后续优化

### 7.1 性能优化
- [ ] 使用硬件加速 (如果 CPU 支持 SM 指令)
- [ ] 优化密钥派生函数 (PRF-SM3)
- [ ] 批量加密优化

### 7.2 功能扩展
- [ ] 支持 SM9 (基于身份的密码)
- [ ] 支持 ZUC (祖冲之序列密码)
- [ ] 支持 SM2 证书链验证
- [ ] 支持 SM2 密钥协商协议 (RFC 6278)

### 7.3 文档完善
- [ ] API 文档 (Doxygen)
- [ ] 用户手册
- [ ] 故障排除指南
- [ ] 性能基准测试报告

---

## 8. 参考资料

### 8.1 GmSSL 文档
- GitHub: https://github.com/guanzhi/GmSSL
- API 文档: https://github.com/guanzhi/GmSSL/tree/master/docs
- SM2 标准: GM/T 0003.1-2012
- SM3 标准: GM/T 0004-2012
- SM4 标准: GM/T 0002-2012

### 8.2 strongSwan 文档
- 插件开发: https://docs.strongswan.org/docs/5.9/devs/pluginArchitecture.html
- API 参考: https://docs.strongswan.org/docs/5.9/api/index.html
- IKEv2 RFC: RFC 7296

### 8.3 密码学标准
- GB/T 32918.1-2016: SM2 椭圆曲线公钥密码算法
- GB/T 32905-2016: SM3 密码杂凑算法
- GB/T 32907-2016: SM4 分组密码算法

---

## 9. 时间估算

| 阶段 | 任务 | 预估时间 |
|------|------|---------|
| 1 | 准备工作 | 1 天 |
| 2 | SM3 哈希实现 | 1 天 |
| 3 | SM4 加密实现 | 1-2 天 |
| 4 | SM2 非对称加密实现 | 2-3 天 |
| 5 | 插件注册 | 1 天 |
| 6 | 核心枚举扩展 | 1 天 |
| 7 | 配置和构建 | 1 天 |
| 8 | 测试验证 | 1-2 天 |
| **总计** | | **9-12 天** |

---

## 10. 下一步行动

### 立即执行
1. ✅ 创建此文档
2. ⏭️ 创建插件目录结构
3. ⏭️ 实现 SM3 哈希器（最简单的组件）
4. ⏭️ 编写单元测试验证 SM3

### 本周目标
- [ ] 完成 SM3 + SM4 实现
- [ ] 通过基础单元测试
- [ ] 验证编译链接无误

### 下周目标
- [ ] 完成 SM2 实现
- [ ] 集成到 IKEv2 协商流程
- [ ] 完整隧道测试

---

**文档版本**: 1.0  
**创建日期**: 2025-10-30  
**作者**: GitHub Copilot  
**状态**: 📝 待实施
