# strongSwan加密算法使用场景与国密算法映射详解

## 目录
1. [使用GmSSL库的方案](#0-使用gmssl库的方案)
2. [关键代码位置总览](#1-关键代码位置总览)
3. [IPsec/IKE协议中的加密算法使用场景](#2-ipsecike协议中的加密算法使用场景)
4. [国际算法与国密算法对应关系](#3-国际算法与国密算法对应关系)
5. [具体修改位置和方法](#4-具体修改位置和方法)
6. [实际应用示例](#5-实际应用示例)

---

## 0. 使用GmSSL库的方案

### 0.1 为什么推荐使用GmSSL？

**GmSSL是北京大学开发的开源密码库**，专门针对中国国密算法优化，使用它可以：

✅ **大幅减少开发工作量**
- 无需自己实现SM2/SM3/SM4的底层算法
- 提供完整的API接口，可直接调用
- 避免70%以上的重复造轮子工作

✅ **保证算法正确性**
- 经过国密局认证
- 通过大量测试用例验证
- 符合GM/T标准规范

✅ **良好的兼容性**
- API设计类似OpenSSL，迁移成本低
- strongSwan已有OpenSSL插件可作参考
- 支持PEM/DER证书格式

✅ **活跃的社区支持**
- GitHub: https://github.com/guanzhi/GmSSL
- 持续维护更新
- 丰富的文档和示例

### 0.2 GmSSL vs 自行实现对比

| 维度 | 使用GmSSL | 自行实现 |
|------|----------|---------|
| **开发工作量** | ~1000行代码（主要是适配层） | ~3000行代码（含算法实现） |
| **开发周期** | 2-3周 | 8-12周 |
| **算法正确性** | ✅ 已验证 | ⚠️ 需大量测试 |
| **性能优化** | ✅ 内置优化（汇编） | ❌ 需手动优化 |
| **安全性审计** | ✅ 已审计 | ⚠️ 需专业审计 |
| **维护成本** | 低（跟随GmSSL更新） | 高（需自行维护） |
| **认证合规** | ✅ 易于通过 | ⚠️ 需额外认证 |

**结论**：**强烈推荐使用GmSSL库**，仅需编写适配层代码即可。

### 0.3 技术方案：基于GmSSL的插件架构

strongSwan支持多种密码库后端（OpenSSL、Botan、GCrypt等），我们采用相同模式创建GmSSL插件：

```
strongSwan现有架构：
    ┌─────────────────────────────────────┐
    │   libstrongswan (核心库)             │
    │   ├─ crypto_factory (算法工厂)       │
    │   └─ plugin_loader (插件加载器)      │
    └─────────────────────────────────────┘
              ↓ 加载插件
    ┌─────────────────────────────────────┐
    │   openssl插件  │ botan插件 │ ...    │
    └─────────────────────────────────────┘
              ↓ 调用底层库
    ┌─────────────────────────────────────┐
    │   OpenSSL    │   Botan   │  ...     │
    └─────────────────────────────────────┘

新增GmSSL插件：
    ┌─────────────────────────────────────┐
    │   libstrongswan (核心库)             │
    │   ├─ crypto_factory (算法工厂)       │
    │   └─ plugin_loader (插件加载器)      │
    └─────────────────────────────────────┘
              ↓ 加载插件
    ┌─────────────────────────────────────┐
    │   gmssl插件  ← 新增                  │
    │   ├─ gmssl_crypter.c (SM4)          │
    │   ├─ gmssl_hasher.c (SM3)           │
    │   ├─ gmssl_signer.c (HMAC-SM3)      │
    │   ├─ gmssl_public_key.c (SM2公钥)   │
    │   └─ gmssl_private_key.c (SM2私钥)  │
    └─────────────────────────────────────┘
              ↓ 调用GmSSL API
    ┌─────────────────────────────────────┐
    │   GmSSL库 (libgmssl.so)              │
    │   ├─ SM4_encrypt/decrypt             │
    │   ├─ SM3_init/update/final           │
    │   ├─ SM2_sign/verify                 │
    │   └─ SM2_compute_key (DH)            │
    └─────────────────────────────────────┘
```

### 0.4 GmSSL API映射到strongSwan

#### SM4加密 (对应 `gmsm_crypter.c`)

```c
// GmSSL提供的API
#include <gmssl/sm4.h>

SM4_KEY sm4_key;
uint8_t iv[16];

// 密钥设置
SM4_set_encrypt_key(&sm4_key, key);  // 加密密钥
SM4_set_decrypt_key(&sm4_key, key);  // 解密密钥

// CBC模式加密
SM4_cbc_encrypt(plaintext, ciphertext, len, &sm4_key, iv, 1);  // 1=加密
SM4_cbc_encrypt(ciphertext, plaintext, len, &sm4_key, iv, 0);  // 0=解密

// CTR模式
SM4_ctr_encrypt(plaintext, ciphertext, len, &sm4_key, iv);

// GCM模式
SM4_GCM_CTX gcm_ctx;
SM4_gcm_init(&gcm_ctx, key, 16, iv, 12, aad, aad_len);
SM4_gcm_update(&gcm_ctx, plaintext, len, ciphertext);
SM4_gcm_finish(&gcm_ctx, tag, 16);
```

**strongSwan适配代码**：
```c
METHOD(crypter_t, encrypt, bool,
    private_gmssl_crypter_t *this, chunk_t data, chunk_t iv,
    chunk_t *encrypted)
{
    switch (this->mode)
    {
        case ENCR_SM4_CBC:
            SM4_cbc_encrypt(data.ptr, encrypted->ptr, data.len,
                           &this->encrypt_key, iv.ptr, 1);
            return TRUE;
        case ENCR_SM4_CTR:
            SM4_ctr_encrypt(data.ptr, encrypted->ptr, data.len,
                           &this->key, iv.ptr);
            return TRUE;
        // ...
    }
}
```

#### SM3哈希 (对应 `gmsm_hasher.c`)

```c
// GmSSL提供的API
#include <gmssl/sm3.h>

SM3_CTX sm3_ctx;
uint8_t hash[32];

// 哈希计算
SM3_init(&sm3_ctx);
SM3_update(&sm3_ctx, data, len);
SM3_final(&sm3_ctx, hash);

// 或一次性计算
SM3(data, len, hash);
```

**strongSwan适配代码**：
```c
METHOD(hasher_t, get_hash, bool,
    private_gmssl_hasher_t *this, chunk_t data, uint8_t *hash)
{
    SM3_update(&this->ctx, data.ptr, data.len);
    if (hash)
    {
        SM3_CTX ctx_copy = this->ctx;
        SM3_final(&ctx_copy, hash);
    }
    return TRUE;
}
```

#### HMAC-SM3 (对应 `gmsm_signer.c`)

```c
// GmSSL提供的API
#include <gmssl/sm3.h>

SM3_HMAC_CTX hmac_ctx;
uint8_t mac[32];

// HMAC计算
SM3_hmac_init(&hmac_ctx, key, key_len);
SM3_hmac_update(&hmac_ctx, data, len);
SM3_hmac_final(&hmac_ctx, mac);

// 或一次性计算
SM3_hmac(key, key_len, data, len, mac);
```

**strongSwan适配代码**：
```c
METHOD(signer_t, get_signature, bool,
    private_gmssl_signer_t *this, chunk_t data, uint8_t *buffer)
{
    SM3_hmac_update(&this->ctx, data.ptr, data.len);
    if (buffer)
    {
        SM3_HMAC_CTX ctx_copy = this->ctx;
        SM3_hmac_final(&ctx_copy, buffer);
    }
    return TRUE;
}
```

#### SM2签名 (对应 `gmsm_private_key.c`)

```c
// GmSSL提供的API
#include <gmssl/sm2.h>

SM2_KEY sm2_key;
uint8_t sig[SM2_MAX_SIGNATURE_SIZE];
size_t siglen;

// 加载私钥
SM2_private_key_from_pem(&sm2_key, fp);

// 签名（自动进行SM3哈希）
SM2_sign(&sm2_key, 
         SM2_DEFAULT_ID, strlen(SM2_DEFAULT_ID),
         message, message_len,
         sig, &siglen);

// 或使用已哈希的数据
SM2_sign_digest(&sm2_key, digest, sig, &siglen);
```

**strongSwan适配代码**：
```c
METHOD(private_key_t, sign, bool,
    private_gmssl_private_key_t *this, signature_scheme_t scheme,
    void *params, chunk_t data, chunk_t *signature)
{
    uint8_t sig[SM2_MAX_SIGNATURE_SIZE];
    size_t siglen = sizeof(sig);
    
    if (scheme == SIGN_SM2_WITH_SM3)
    {
        // GmSSL会自动进行SM3哈希
        if (!SM2_sign(&this->key, SM2_DEFAULT_ID, strlen(SM2_DEFAULT_ID),
                     data.ptr, data.len, sig, &siglen))
        {
            return FALSE;
        }
    }
    else if (scheme == SIGN_SM2_WITH_NULL)
    {
        // 数据已经是哈希值
        if (!SM2_sign_digest(&this->key, data.ptr, sig, &siglen))
        {
            return FALSE;
        }
    }
    
    *signature = chunk_clone(chunk_create(sig, siglen));
    return TRUE;
}
```

#### SM2验证 (对应 `gmsm_public_key.c`)

```c
// GmSSL提供的API
SM2_KEY sm2_key;

// 加载公钥
SM2_public_key_from_pem(&sm2_key, fp);

// 验证签名
int valid = SM2_verify(&sm2_key,
                       SM2_DEFAULT_ID, strlen(SM2_DEFAULT_ID),
                       message, message_len,
                       signature, signature_len);

// 或验证摘要
int valid = SM2_verify_digest(&sm2_key, digest, signature, signature_len);
```

**strongSwan适配代码**：
```c
METHOD(public_key_t, verify, bool,
    private_gmssl_public_key_t *this, signature_scheme_t scheme,
    void *params, chunk_t data, chunk_t signature)
{
    if (scheme == SIGN_SM2_WITH_SM3)
    {
        return SM2_verify(&this->key, SM2_DEFAULT_ID, strlen(SM2_DEFAULT_ID),
                         data.ptr, data.len,
                         signature.ptr, signature.len) == 1;
    }
    else if (scheme == SIGN_SM2_WITH_NULL)
    {
        return SM2_verify_digest(&this->key, data.ptr,
                                signature.ptr, signature.len) == 1;
    }
    return FALSE;
}
```

### 0.5 使用GmSSL的实施步骤

#### 步骤1：安装GmSSL库（1天）

```bash
# 下载GmSSL源码
git clone https://github.com/guanzhi/GmSSL.git
cd GmSSL

# 编译安装
mkdir build && cd build
cmake ..
make
sudo make install

# 验证安装
ls /usr/local/lib/libgmssl.so
ls /usr/local/include/gmssl/
```

#### 步骤2：创建gmssl插件骨架（1天）

```bash
cd strongswan/src/libstrongswan/plugins
mkdir gmssl
cd gmssl

# 创建文件
touch gmssl_plugin.{h,c}
touch gmssl_crypter.{h,c}
touch gmssl_hasher.{h,c}
touch gmssl_signer.{h,c}
touch gmssl_public_key.{h,c}
touch gmssl_private_key.{h,c}
touch Makefile.am
```

#### 步骤3：实现各个算法模块（5-7天）

| 模块 | 文件 | 工作量 | GmSSL API |
|-----|------|--------|----------|
| SM4加密 | `gmssl_crypter.c` | 1天 | `SM4_set_key()`, `SM4_cbc_encrypt()` |
| SM3哈希 | `gmssl_hasher.c` | 0.5天 | `SM3_init()`, `SM3_update()`, `SM3_final()` |
| HMAC-SM3 | `gmssl_signer.c` | 0.5天 | `SM3_hmac_init()`, `SM3_hmac()` |
| SM2公钥 | `gmssl_public_key.c` | 1.5天 | `SM2_public_key_from_pem()`, `SM2_verify()` |
| SM2私钥 | `gmssl_private_key.c` | 1.5天 | `SM2_private_key_from_pem()`, `SM2_sign()` |
| 插件注册 | `gmssl_plugin.c` | 1天 | - |

#### 步骤4：添加枚举和配置（1天）

- 修改 `crypter.h`, `hasher.h`, `signer.h`, `public_key.h`
- 添加算法关键字到 `proposal_keywords_static.txt`
- 添加OID映射到 `oid.c`

#### 步骤5：配置构建系统（1天）

```makefile
# src/libstrongswan/plugins/gmssl/Makefile.am
AM_CPPFLAGS = \
    -I$(top_srcdir)/src/libstrongswan \
    @GMSSL_CFLAGS@

plugin_LTLIBRARIES = libstrongswan-gmssl.la

libstrongswan_gmssl_la_SOURCES = \
    gmssl_plugin.h gmssl_plugin.c \
    gmssl_crypter.h gmssl_crypter.c \
    gmssl_hasher.h gmssl_hasher.c \
    gmssl_signer.h gmssl_signer.c \
    gmssl_public_key.h gmssl_public_key.c \
    gmssl_private_key.h gmssl_private_key.c

libstrongswan_gmssl_la_LDFLAGS = -module -avoid-version
libstrongswan_gmssl_la_LIBADD = @GMSSL_LIBS@
```

```bash
# configure.ac 添加
ARG_ENABLE_SET([gmssl],
    [enable gmssl crypto plugin (国密算法支持).],
    [PLUGINS="$PLUGINS gmssl"])
AM_CONDITIONAL(USE_GMSSL, test x$gmssl = xtrue)

# 检测GmSSL库
if test x$gmssl = xtrue; then
    AC_CHECK_LIB([gmssl], [SM4_set_encrypt_key],
        [GMSSL_LIBS="-lgmssl"],
        [AC_MSG_ERROR([GmSSL library not found])])
    AC_CHECK_HEADERS([gmssl/sm4.h gmssl/sm3.h gmssl/sm2.h],
        [],
        [AC_MSG_ERROR([GmSSL headers not found])])
fi
AC_SUBST(GMSSL_LIBS)
```

#### 步骤6：测试验证（3-5天）

```bash
# 编译
./autogen.sh
./configure --enable-gmssl
make

# 单元测试
make check

# 集成测试
cd testing
./start-testing ikev2/gm-algorithms
```

### 0.6 代码量对比

| 方案 | 核心代码 | 测试代码 | 配置代码 | 总计 |
|-----|---------|---------|---------|------|
| **使用GmSSL** | ~1000行 | ~500行 | ~200行 | **~1700行** |
| **自行实现** | ~3000行 | ~1000行 | ~200行 | **~4200行** |
| **节省比例** | **67%** | **50%** | **0%** | **60%** |

### 0.7 参考：OpenSSL插件结构

strongSwan已有的OpenSSL插件可作为GmSSL插件的模板：

```bash
src/libstrongswan/plugins/openssl/
├── openssl_plugin.c          # 插件主文件（注册所有算法）
├── openssl_crypter.c         # AES/DES等加密算法
├── openssl_hasher.c          # SHA系列哈希
├── openssl_hmac.c            # HMAC实现
├── openssl_rsa_public_key.c  # RSA公钥
├── openssl_rsa_private_key.c # RSA私钥
├── openssl_ec_public_key.c   # ECDSA公钥
├── openssl_ec_private_key.c  # ECDSA私钥
└── ...

# 创建GmSSL插件时，可以参考这些文件的结构：
src/libstrongswan/plugins/gmssl/
├── gmssl_plugin.c            # 类似openssl_plugin.c
├── gmssl_crypter.c           # 类似openssl_crypter.c（改用SM4 API）
├── gmssl_hasher.c            # 类似openssl_hasher.c（改用SM3 API）
├── gmssl_signer.c            # 类似openssl_hmac.c（改用SM3_hmac API）
├── gmssl_public_key.c        # 类似openssl_ec_public_key.c（改用SM2 API）
└── gmssl_private_key.c       # 类似openssl_ec_private_key.c（改用SM2 API）
```

### 0.8 最终建议

✅ **强烈推荐使用GmSSL方案**

**理由**：
1. **开发周期缩短60%**：从12周降至5周
2. **代码量减少60%**：从4200行降至1700行
3. **质量保证**：使用经过验证的国密实现
4. **易于维护**：跟随GmSSL库更新即可
5. **合规性强**：GmSSL已通过国密认证

**实施路径**：
```
Week 1: 环境搭建 + 插件骨架
Week 2: SM4/SM3/HMAC-SM3实现
Week 3: SM2公钥/私钥实现  
Week 4: 集成测试 + Bug修复
Week 5: 性能优化 + 文档完善
```

**风险最小化**：
- GmSSL是成熟的开源项目，社区活跃
- API稳定，向后兼容性好
- 有大量参考示例和文档

---

## 0. 关键代码位置总览

### 0.1 加密算法调用流程图

```
IKE协商开始
    ↓
[ike_init.c] 
    发起/响应IKE_SA_INIT交换
    ├─ 创建DH密钥交换对象 (create_ke)
    ├─ 生成随机数 (nonce)
    └─ 选择算法提案 (select_proposal)
         ↓
[keymat_v2.c::derive_ike_keys] 第240行
    IKE密钥派生（核心函数）
    ├─ 获取PRF算法 → create_prf(PRF_HMAC_SM3)
    ├─ 获取加密算法 → ENCR_SM4_CBC/GCM
    ├─ 获取完整性算法 → AUTH_HMAC_SM3_128
    ├─ 计算SKEYSEED = prf(Ni|Nr, g^ir)
    └─ 派生SK_d, SK_ai, SK_ar, SK_ei, SK_er, SK_pi, SK_pr
         ↓
[AEAD对象创建]
    ├─ 加密器：lib->crypto->create_crypter(ENCR_SM4_CBC)
    ├─ 签名器：lib->crypto->create_signer(AUTH_HMAC_SM3_128)
    └─ IV生成器：lib->crypto->create_iv_gen()
         ↓
IKE_AUTH交换
    ↓
[pubkey_authenticator.c::build] 第310行
    生成认证数据（发送方）
    ├─ 选择签名方案 → select_signature_schemes()
    │   └─ 返回 SIGN_SM2_WITH_SM3
    ├─ 获取待签名数据 → keymat->get_auth_octets()
    │   └─ 使用PRF_HMAC_SM3派生
    └─ 私钥签名 → private->sign(SIGN_SM2_WITH_SM3)
         └─ 调用SM2签名算法
         ↓
[pubkey_authenticator.c::process] 第570行
    验证认证数据（接收方）
    ├─ 解析签名方案 → parse_signature_auth_data()
    │   └─ 提取 SIGN_SM2_WITH_SM3
    ├─ 加载公钥证书 → create_public_enumerator()
    │   └─ [x509_cert.c::issued_by] 验证证书链
    │       └─ CA公钥->verify(SIGN_SM2_WITH_SM3)
    └─ 验证签名 → public->verify(SIGN_SM2_WITH_SM3)
         └─ 调用SM2验证算法
         ↓
[keymat_v2.c::derive_child_keys] 第540行
    ESP密钥派生
    ├─ 获取ESP加密算法 → ENCR_SM4_GCM_ICV16
    ├─ 获取ESP完整性算法 → AUTH_HMAC_SM3_128
    ├─ 使用PRF_HMAC_SM3派生密钥
    └─ 返回 encr_i, integ_i, encr_r, integ_r
         ↓
ESP数据传输
    ↓
[esp_packet.c::encrypt] 第289行
    ESP加密（发送方）
    ├─ 获取AEAD对象 → esp_context->get_aead()
    │   └─ SM4加密器 + HMAC-SM3签名器
    ├─ 生成IV → iv_gen->get_iv()
    ├─ 填充数据 → generate_padding()
    └─ 加密并计算ICV → aead->encrypt()
         ├─ crypter->encrypt() → SM4-CBC/GCM加密
         └─ signer->get_signature() → HMAC-SM3计算ICV
         ↓
[esp_packet.c::decrypt] 第228行
    ESP解密（接收方）
    ├─ 获取AEAD对象 → esp_context->get_aead()
    ├─ 验证序列号 → verify_seqno()
    └─ 解密并验证ICV → aead->decrypt()
         ├─ signer->verify() → HMAC-SM3验证ICV
         └─ crypter->decrypt() → SM4-CBC/GCM解密
```

### 0.2 核心文件清单

#### IKE协商层
| 文件路径 | 主要功能 | 涉及的国密算法 | 关键函数 |
|---------|---------|--------------|---------|
| `src/libcharon/sa/ikev2/tasks/ike_init.c` | IKE_SA初始化 | DH密钥交换 | `build_i()`, `process_r()` |
| `src/libcharon/sa/ikev2/keymat_v2.c` | IKE密钥材料派生 | PRF-HMAC-SM3, SM4, HMAC-SM3 | `derive_ike_keys()` 第240行<br>`derive_child_keys()` 第540行 |
| `src/libcharon/sa/ikev2/authenticators/pubkey_authenticator.c` | 公钥认证 | SM2签名/验证 | `build()` 第310行<br>`process()` 第570行 |

#### ESP数据层
| 文件路径 | 主要功能 | 涉及的国密算法 | 关键函数 |
|---------|---------|--------------|---------|
| `src/libipsec/esp_packet.c` | ESP封装/解封装 | SM4加密, HMAC-SM3 | `encrypt()` 第289行<br>`decrypt()` 第228行 |
| `src/libipsec/esp_context.c` | ESP上下文管理 | SM4, HMAC-SM3 | `set_keys()`, `get_aead()` |

#### 证书和密钥层
| 文件路径 | 主要功能 | 涉及的国密算法 | 关键函数 |
|---------|---------|--------------|---------|
| `src/libstrongswan/plugins/x509/x509_cert.c` | X.509证书处理 | SM2签名验证, SM3哈希 | `issued_by()` 第1718行<br>`parse_certificate()` |
| `src/libstrongswan/credentials/keys/public_key.h` | 公钥接口定义 | SM2 | `sign()`, `verify()` |
| `src/libstrongswan/credentials/keys/private_key.h` | 私钥接口定义 | SM2 | `sign()` |

#### 密码算法层
| 文件路径 | 主要功能 | 涉及的国密算法 | 关键函数 |
|---------|---------|--------------|---------|
| `src/libstrongswan/crypto/crypters/crypter.h` | 加密器接口 | SM4 | `encrypt()`, `decrypt()` |
| `src/libstrongswan/crypto/hashers/hasher.h` | 哈希接口 | SM3 | `get_hash()` |
| `src/libstrongswan/crypto/signers/signer.h` | 签名器接口 | HMAC-SM3 | `get_signature()`, `verify_signature()` |
| `src/libstrongswan/crypto/prfs/prf.h` | PRF接口 | PRF-HMAC-SM3 | `get_bytes()`, `allocate_bytes()` |

#### 算法工厂层
| 文件路径 | 主要功能 | 涉及的国密算法 | 关键函数 |
|---------|---------|--------------|---------|
| `src/libstrongswan/crypto/crypto_factory.c` | 算法工厂 | 所有国密算法 | `create_crypter()`<br>`create_hasher()`<br>`create_signer()`<br>`create_prf()` |

#### 算法定义层
| 文件路径 | 主要功能 | 涉及的国密算法 | 修改内容 |
|---------|---------|--------------|---------|
| `src/libstrongswan/crypto/crypters/crypter.h` | 加密算法枚举 | ENCR_SM4_* | 添加枚举值 |
| `src/libstrongswan/crypto/hashers/hasher.h` | 哈希算法枚举 | HASH_SM3 | 添加枚举值 |
| `src/libstrongswan/crypto/signers/signer.h` | 完整性算法枚举 | AUTH_HMAC_SM3_* | 添加枚举值 |
| `src/libstrongswan/credentials/keys/public_key.h` | 密钥类型/签名方案 | KEY_SM2, SIGN_SM2_WITH_SM3 | 添加枚举值 |
| `src/libstrongswan/asn1/oid.c` | OID映射 | SM2/SM3/SM4 OID | 添加OID定义 |

### 0.3 算法调用时序

```
时间轴：IKE_SA_INIT → IKE_AUTH → CREATE_CHILD_SA → ESP数据传输

┌─────────────────────────────────────────────────────────────┐
│ IKE_SA_INIT阶段 (keymat_v2.c::derive_ike_keys)              │
├─────────────────────────────────────────────────────────────┤
│ 1. PRF_HMAC_SM3                                             │
│    ├─ 用途：计算SKEYSEED                                     │
│    ├─ 输入：Ni, Nr, DH共享密钥                               │
│    └─ 输出：SKEYSEED                                        │
│                                                             │
│ 2. PRF_HMAC_SM3 (PRF+模式)                                  │
│    ├─ 用途：派生密钥材料                                     │
│    ├─ 输入：SKEYSEED, Ni, Nr, SPIi, SPIr                    │
│    └─ 输出：SK_d, SK_ai, SK_ar, SK_ei, SK_er, SK_pi, SK_pr │
│                                                             │
│ 3. SM4加密器 + HMAC-SM3签名器                                │
│    ├─ 用途：加密/完整性保护IKE消息                            │
│    ├─ 密钥：SK_ei/SK_er (加密), SK_ai/SK_ar (完整性)        │
│    └─ 应用：后续所有IKE消息                                  │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ IKE_AUTH阶段 (pubkey_authenticator.c)                       │
├─────────────────────────────────────────────────────────────┤
│ 4. PRF_HMAC_SM3                                             │
│    ├─ 用途：计算待签名数据                                   │
│    ├─ 输入：IKE_SA_INIT消息, Nonce, ID, SK_p               │
│    └─ 输出：auth_octets                                     │
│                                                             │
│ 5. SM3哈希                                                  │
│    ├─ 用途：对auth_octets进行哈希                           │
│    ├─ 输入：auth_octets                                     │
│    └─ 输出：32字节哈希值                                     │
│                                                             │
│ 6. SM2签名 (private_key->sign)                              │
│    ├─ 用途：生成数字签名                                     │
│    ├─ 输入：SM3哈希值, SM2私钥                              │
│    └─ 输出：64字节签名 (r, s)                               │
│                                                             │
│ 7. SM2验证 (public_key->verify)                             │
│    ├─ 用途：验证对端签名                                     │
│    ├─ 输入：SM3哈希值, 签名, SM2公钥                        │
│    └─ 输出：TRUE/FALSE                                      │
│                                                             │
│ 8. SM3哈希 (x509_cert.c::issued_by)                        │
│    ├─ 用途：验证证书签名                                     │
│    ├─ 输入：证书TBS部分                                      │
│    └─ 输出：32字节哈希值 → SM2验证                          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ CREATE_CHILD_SA阶段 (keymat_v2.c::derive_child_keys)        │
├─────────────────────────────────────────────────────────────┤
│ 9. PRF_HMAC_SM3 (PRF+模式)                                  │
│    ├─ 用途：派生ESP密钥                                      │
│    ├─ 输入：SK_d, Ni, Nr, [DH共享密钥]                      │
│    └─ 输出：encr_i, integ_i, encr_r, integ_r               │
│                                                             │
│ 10. SM4加密器 + HMAC-SM3签名器（ESP用）                      │
│     ├─ 用途：ESP数据包加密/完整性保护                        │
│     ├─ 密钥：encr_i/encr_r (加密), integ_i/integ_r (完整性) │
│     └─ 应用：所有ESP数据包                                   │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ ESP数据传输阶段 (esp_packet.c)                               │
├─────────────────────────────────────────────────────────────┤
│ 11. SM4加密 (encrypt函数 第289行)                            │
│     ├─ 模式：SM4-CBC或SM4-GCM                               │
│     ├─ 输入：IP数据包 + IV                                   │
│     └─ 输出：密文                                            │
│                                                             │
│ 12. HMAC-SM3 (encrypt函数 - 非AEAD模式)                     │
│     ├─ 输入：SPI, Seq, IV, 密文                             │
│     └─ 输出：ICV（16字节）                                   │
│                                                             │
│ 13. SM4解密 (decrypt函数 第228行)                            │
│     ├─ 模式：SM4-CBC或SM4-GCM                               │
│     ├─ 输入：密文 + IV                                       │
│     └─ 输出：明文IP数据包                                    │
│                                                             │
│ 14. HMAC-SM3验证 (decrypt函数 - 非AEAD模式)                 │
│     ├─ 输入：SPI, Seq, IV, 密文, ICV                        │
│     └─ 输出：验证成功/失败                                   │
└─────────────────────────────────────────────────────────────┘
```

### 0.4 国密算法集成检查清单

在实施国密改造时，需要确保以下每个位置都正确支持国密算法：

- [ ] **枚举定义**（10个位置）
  - [ ] `crypter.h`: ENCR_SM4_CBC, ENCR_SM4_GCM_ICV16 等
  - [ ] `hasher.h`: HASH_SM3
  - [ ] `signer.h`: AUTH_HMAC_SM3_128, AUTH_HMAC_SM3_256
  - [ ] `prf.h`: PRF_HMAC_SM3
  - [ ] `public_key.h`: KEY_SM2, SIGN_SM2_WITH_SM3
  - [ ] `key_exchange.h`: KE_SM2_256 (如果实现DH)
  - [ ] `oid.h`: OID_SM2, OID_SM3, OID_SM2_WITH_SM3

- [ ] **算法工厂注册**（1个位置）
  - [ ] `crypto_factory.c`: 支持创建SM4/SM3/HMAC-SM3/SM2实例

- [ ] **插件实现**（6个文件）
  - [ ] `gmsm_plugin.c`: 注册所有国密算法
  - [ ] `gmsm_crypter.c`: SM4加密器实现
  - [ ] `gmsm_hasher.c`: SM3哈希实现
  - [ ] `gmsm_signer.c`: HMAC-SM3实现
  - [ ] `gmsm_public_key.c`: SM2公钥实现
  - [ ] `gmsm_private_key.c`: SM2私钥实现

- [ ] **算法关键字**（1个位置）
  - [ ] `proposal_keywords_static.txt`: sm4, sm3, sm2dh 等

- [ ] **OID映射**（1个位置）
  - [ ] `oid.c`: 添加国密算法OID定义

- [ ] **密钥派生**（2个位置）
  - [ ] `keymat_v2.c::derive_ike_keys`: 支持PRF_HMAC_SM3
  - [ ] `keymat_v2.c::derive_child_keys`: 支持PRF_HMAC_SM3

- [ ] **认证**（2个位置）
  - [ ] `pubkey_authenticator.c::build`: 支持SIGN_SM2_WITH_SM3
  - [ ] `pubkey_authenticator.c::process`: 支持SIGN_SM2_WITH_SM3

- [ ] **证书**（2个位置）
  - [ ] `x509_cert.c::issued_by`: 支持SM2签名验证
  - [ ] `x509_cert.c::parse_certificate`: 支持SM2 OID

- [ ] **ESP数据**（2个位置）
  - [ ] `esp_packet.c::encrypt`: 支持SM4加密
  - [ ] `esp_packet.c::decrypt`: 支持SM4解密

---

## 1. 关键代码位置总览

### 1.1 加密算法调用流程图

IKE协议用于建立安全关联（SA），在这个过程中需要多种加密算法：

#### 场景1：IKE消息加密
**用途**：保护IKE协商消息的机密性

**当前使用的算法**：
- AES-CBC (128/192/256位)
- AES-GCM (AEAD模式)
- ChaCha20-Poly1305
- 3DES (已不推荐)

**国密替代方案**：
```
AES-CBC-128  →  SM4-CBC-128
AES-CBC-192  →  SM4-CBC-128 (SM4只支持128位密钥)
AES-CBC-256  →  SM4-CBC-128
AES-GCM-128  →  SM4-GCM-128 (AEAD模式)
3DES         →  SM4-CBC-128
```

**代码位置**：
```
src/libstrongswan/crypto/crypters/crypter.h  # 算法枚举定义
src/libcharon/sa/ikev2/keymat_v2.c           # IKE密钥材料派生
src/libcharon/sa/ikev2/tasks/ike_init.c      # IKE初始化
```

---

#### 场景2：IKE消息完整性保护
**用途**：确保IKE消息未被篡改

**当前使用的算法**：
- HMAC-SHA1-96
- HMAC-SHA2-256-128
- HMAC-SHA2-384-192
- HMAC-SHA2-512-256

**国密替代方案**：
```
HMAC-SHA1-96       →  HMAC-SM3-128 (或HMAC-SM3-256)
HMAC-SHA2-256-128  →  HMAC-SM3-128
HMAC-SHA2-256-256  →  HMAC-SM3-256
HMAC-SHA2-384-192  →  HMAC-SM3-256
HMAC-SHA2-512-256  →  HMAC-SM3-256
```

**代码位置**：
```
src/libstrongswan/crypto/signers/signer.h    # 完整性算法定义
src/libstrongswan/crypto/mac.h               # MAC算法接口
```

---

#### 场景3：密钥派生函数（PRF）
**用途**：从共享密钥派生加密密钥、认证密钥等

**当前使用的算法**：
- PRF_HMAC_SHA1
- PRF_HMAC_SHA2_256
- PRF_HMAC_SHA2_384
- PRF_HMAC_SHA2_512

**国密替代方案**：
```
PRF_HMAC_SHA1      →  PRF_HMAC_SM3
PRF_HMAC_SHA2_256  →  PRF_HMAC_SM3
PRF_HMAC_SHA2_384  →  PRF_HMAC_SM3
PRF_HMAC_SHA2_512  →  PRF_HMAC_SM3
```

**代码位置**：
```
src/libstrongswan/crypto/prfs/prf.h          # PRF算法定义
src/libcharon/sa/ikev2/keymat_v2.c           # 密钥派生实现
```

**关键函数示例**：
```c
// src/libcharon/sa/ikev2/keymat_v2.c 第240-290行
METHOD(keymat_v2_t, derive_ike_keys, bool,
    private_keymat_v2_t *this, proposal_t *proposal, array_t *kes,
    chunk_t nonce_i, chunk_t nonce_r, ike_sa_id_t *id,
    pseudo_random_function_t rekey_function, chunk_t rekey_skd)
{
    kdf_t *prf = NULL, *prf_plus = NULL;
    uint16_t prf_alg, key_size, enc_alg, enc_size, int_alg;
    
    // 1. 从提案中获取PRF算法（国密改造点：需要支持PRF_HMAC_SM3）
    if (!proposal->get_algorithm(proposal, PSEUDO_RANDOM_FUNCTION, &prf_alg,
                                 NULL))
    {
        DBG1(DBG_IKE, "no %N selected",
             transform_type_names, PSEUDO_RANDOM_FUNCTION);
        return FALSE;
    }
    this->prf_alg = prf_alg;  // 可能是 PRF_HMAC_SHA2_256 或 PRF_HMAC_SM3
    
    // 2. 创建PRF实例（国密改造点：crypto_factory需支持SM3）
    DESTROY_IF(this->prf);
    this->prf = lib->crypto->create_prf(lib->crypto, this->prf_alg);
    if (!this->prf)
    {
        DBG1(DBG_IKE, "%N %N not supported!", transform_type_names,
             PSEUDO_RANDOM_FUNCTION, pseudo_random_function_names,
             this->prf_alg);
        return FALSE;
    }
    key_size = this->prf->get_key_size(this->prf);
    
    // 3. 从提案中获取加密算法（国密改造点：需要支持ENCR_SM4_CBC/GCM）
    if (!proposal->get_algorithm(proposal, ENCRYPTION_ALGORITHM, &enc_alg,
                                 &enc_size))
    {
        DBG1(DBG_IKE, "no %N selected", transform_type_names,
             ENCRYPTION_ALGORITHM);
        return FALSE;
    }
    // enc_alg 可能是 ENCR_AES_CBC 或 ENCR_SM4_CBC
    // enc_size 是密钥长度（SM4固定128位）
    
    // 4. 创建加密器和完整性保护（国密改造点：需要支持SM4和HMAC-SM3）
    DESTROY_IF(this->aead_in);
    DESTROY_IF(this->aead_out);
    if (!encryption_algorithm_is_aead(enc_alg))
    {
        // 非AEAD模式（如CBC），需要单独的完整性算法
        if (!proposal->get_algorithm(proposal, INTEGRITY_ALGORITHM, &int_alg,
                                     NULL))
        {
            DBG1(DBG_IKE, "no %N selected", transform_type_names,
                 INTEGRITY_ALGORITHM);
            return FALSE;
        }
        // int_alg 可能是 AUTH_HMAC_SHA2_256_128 或 AUTH_HMAC_SM3_128
        if (!create_ike_traditional(this, enc_alg, enc_size, int_alg,
                                     &sk_ai, &sk_ar, &sk_ei, &sk_er))
        {
            return FALSE;
        }
    }
    else
    {
        // AEAD模式（如GCM）
        // enc_alg 可能是 ENCR_AES_GCM_ICV16 或 ENCR_SM4_GCM_ICV16
        if (!create_ike_aead(this, enc_alg, enc_size, &sk_ei, &sk_er))
        {
            return FALSE;
        }
    }
}
```

**后续的密钥派生过程**（第330-420行）：
```c
    // 5. 计算SKEYSEED（使用PRF-HMAC-SM3）
    // SKEYSEED = prf(Ni | Nr, g^ir)
    prf = lib->crypto->create_kdf(lib->crypto, KDF_PRF, this->prf_alg);
    if (!prf)
    {
        DBG1(DBG_IKE, "%N with %N not supported",
             key_derivation_function_names, KDF_PRF,
             pseudo_random_function_names, this->prf_alg);
        return FALSE;
    }
    
    // 6. 使用PRF+派生密钥材料（国密改造点：使用PRF-HMAC-SM3）
    prf_plus = lib->crypto->create_kdf(lib->crypto, KDF_PRF_PLUS, this->prf_alg);
    
    // 7. 派生所有密钥：SK_d | SK_ai | SK_ar | SK_ei | SK_er | SK_pi | SK_pr
    keymat.len = 3 * key_size + sk_ai.len + sk_ar.len + sk_ei.len + sk_er.len;
    if (!prf_plus->allocate_bytes(prf_plus, keymat.len, &keymat))
    {
        goto failure;
    }
    
    // SK_d: 用于派生CHILD_SA密钥（存储用于ESP）
    // SK_ai/SK_ar: IKE消息完整性密钥（使用HMAC-SM3）
    // SK_ei/SK_er: IKE消息加密密钥（使用SM4）
    // SK_pi/SK_pr: 认证密钥（用于签名验证）
    chunk_split(keymat, "ammmmaa", key_size, &this->skd, sk_ai.len, &sk_ai,
                sk_ar.len, &sk_ar, sk_ei.len, &sk_ei, sk_er.len, &sk_er,
                key_size, &sk_pi, key_size, &sk_pr);
```

---

#### 场景4：密钥交换（DH组）
**用途**：协商共享密钥

**当前使用的算法**：
- MODP组 (DH组14, 15, 16等)
- ECP组 (椭圆曲线，如P-256, P-384, P-521)
- Curve25519
- Curve448

**国密替代方案**：
```
MODP-2048      →  SM2-256 (椭圆曲线密钥交换)
ECP-256        →  SM2-256
ECP-384        →  SM2-256 (SM2固定256位)
Curve25519     →  SM2-256
```

**代码位置**：
```
src/libstrongswan/crypto/key_exchange.h      # DH算法定义
src/libcharon/sa/ikev2/tasks/ike_init.c      # DH密钥交换
```

---

### 1.2 IPsec数据传输阶段（CHILD_SA/ESP）

#### 场景5：ESP加密
**用途**：加密IP数据包载荷

**当前使用的算法**：
- AES-CBC (128/192/256位)
- AES-CTR (128/192/256位)
- AES-GCM (AEAD)
- ChaCha20-Poly1305

**国密替代方案**：
```
AES-CBC-128    →  SM4-CBC-128
AES-CBC-192    →  SM4-CBC-128
AES-CBC-256    →  SM4-CBC-128
AES-CTR-128    →  SM4-CTR-128
AES-GCM-128    →  SM4-GCM-128
```

**代码位置**：
```
src/libipsec/esp_packet.c                    # ESP数据包处理
src/libcharon/plugins/kernel-netlink/        # Linux内核接口
```

**详细代码调用链**：

**加密路径**（src/libipsec/esp_packet.c 第289-380行）：
```c
METHOD(esp_packet_t, encrypt, status_t,
    private_esp_packet_t *this, esp_context_t *esp_context, uint32_t spi)
{
    chunk_t iv, icv, aad, padding, payload, ciphertext;
    bio_writer_t *writer;
    uint32_t next_seqno;
    size_t blocksize, plainlen;
    aead_t *aead;
    iv_gen_t *iv_gen;

    // 1. 获取序列号
    if (!esp_context->next_seqno(esp_context, &next_seqno))
    {
        DBG1(DBG_ESP, "ESP encapsulation failed: sequence numbers cycled");
        return FAILED;
    }

    // 2. 获取AEAD实例（可能是SM4-GCM或SM4-CBC+HMAC-SM3）
    aead = esp_context->get_aead(esp_context);
    iv_gen = aead->get_iv_gen(aead);
    if (!iv_gen)
    {
        DBG1(DBG_ESP, "ESP encryption failed: no IV generator");
        return NOT_FOUND;
    }

    blocksize = aead->get_block_size(aead);  // SM4是16字节
    iv.len = aead->get_iv_size(aead);        // SM4-CBC是16字节，GCM是8字节
    icv.len = aead->get_icv_size(aead);      // HMAC-SM3-128是16字节

    // 3. 准备明文（payload + padding + pad_length + next_header）
    payload = this->payload ? this->payload->get_encoding(this->payload)
                            : chunk_empty;
    plainlen = payload.len + 2;
    padding.len = pad_len(plainlen, blocksize);
    padding.len += pad_len(iv.len + plainlen + padding.len, 4);
    plainlen += padding.len;

    // 4. 构建ESP头部（SPI + Seq + IV）
    writer = bio_writer_create(2 * sizeof(uint32_t) + iv.len + plainlen +
                               icv.len);
    writer->write_uint32(writer, ntohl(spi));
    writer->write_uint32(writer, next_seqno);

    // 5. 生成IV
    iv = writer->skip(writer, iv.len);
    if (!iv_gen->get_iv(iv_gen, next_seqno, iv.len, iv.ptr))
    {
        DBG1(DBG_ESP, "ESP encryption failed: could not generate IV");
        writer->destroy(writer);
        return FAILED;
    }

    // 6. 写入明文数据（待加密部分）
    ciphertext = writer->get_buf(writer);
    ciphertext.ptr += ciphertext.len;
    ciphertext.len = plainlen;
    
    writer->write_data(writer, payload);
    generate_padding(writer->skip(writer, padding.len));
    writer->write_uint8(writer, padding.len);
    writer->write_uint8(writer, this->next_header);

    // 7. 使用SM4加密（关键调用点）
    // AAD = SPI + Seq（认证但不加密的数据）
    aad = chunk_create(data.ptr, 8);
    icv = writer->skip(writer, icv.len);
    
    // 调用aead->encrypt()，内部会：
    // - 如果是SM4-CBC模式：先用SM4-CBC加密，再用HMAC-SM3计算ICV
    // - 如果是SM4-GCM模式：使用SM4-GCM一步完成加密和认证
    if (!aead->encrypt(aead, ciphertext, aad, iv, &icv))
    {
        DBG1(DBG_ESP, "ESP encryption failed");
        writer->destroy(writer);
        return FAILED;
    }

    // 8. 保存加密后的数据包
    this->packet->set_data(this->packet, writer->get_buf(writer));
    writer->destroy(writer);
    
    DBG3(DBG_ESP, "ESP encryption:\n  SPI %.8x [seq %u]\n  IV %B\n  "
         "encrypted %B\n  ICV %B", ntohl(spi), next_seqno, &iv, 
         &ciphertext, &icv);
    
    return SUCCESS;
}
```

**解密路径**（src/libipsec/esp_packet.c 第228-285行）：
```c
METHOD(esp_packet_t, decrypt, status_t,
    private_esp_packet_t *this, esp_context_t *esp_context)
{
    bio_reader_t *reader;
    uint32_t spi, seq;
    chunk_t data, iv, icv, aad, ciphertext, plaintext;
    aead_t *aead;

    DESTROY_IF(this->payload);
    this->payload = NULL;

    data = this->packet->get_data(this->packet);
    aead = esp_context->get_aead(esp_context);  // 获取SM4实例

    // 1. 解析ESP头部
    reader = bio_reader_create(data);
    if (!reader->read_uint32(reader, &spi) ||
        !reader->read_uint32(reader, &seq) ||
        !reader->read_data(reader, aead->get_iv_size(aead), &iv) ||
        !reader->read_data_end(reader, aead->get_icv_size(aead), &icv) ||
        reader->remaining(reader) % aead->get_block_size(aead))
    {
        DBG1(DBG_ESP, "ESP decryption failed: invalid length");
        return PARSE_ERROR;
    }
    ciphertext = reader->peek(reader);
    reader->destroy(reader);

    // 2. 验证序列号（防重放攻击）
    if (!esp_context->verify_seqno(esp_context, seq))
    {
        DBG1(DBG_ESP, "ESP sequence number verification failed:\n  "
             "src %H, dst %H, SPI %.8x [seq %u]",
             get_source(this), get_destination(this), spi, seq);
        return VERIFY_ERROR;
    }
    
    DBG3(DBG_ESP, "ESP decryption:\n  SPI %.8x [seq %u]\n  IV %B\n  "
         "encrypted %B\n  ICV %B", spi, seq, &iv, &ciphertext, &icv);

    // 3. 使用SM4解密并验证（关键调用点）
    ciphertext.len += icv.len;  // ICV包含在密文中
    aad = chunk_create(data.ptr, 8);  // AAD = SPI + Seq

    // 调用aead->decrypt()，内部会：
    // - 如果是SM4-CBC模式：先用HMAC-SM3验证ICV，再用SM4-CBC解密
    // - 如果是SM4-GCM模式：使用SM4-GCM一步完成解密和验证
    if (!aead->decrypt(aead, ciphertext, aad, iv, &plaintext))
    {
        DBG1(DBG_ESP, "ESP decryption or ICV verification failed");
        return FAILED;  // 解密失败或完整性验证失败
    }
    esp_context->set_authenticated_seqno(esp_context, seq);

    // 4. 移除填充，提取原始IP包
    if (!remove_padding(this, plaintext))
    {
        return PARSE_ERROR;
    }
    return SUCCESS;
}
```

**AEAD对象创建**（在keymat_v2.c中，传递给ESP）：
```c
// src/libcharon/sa/ikev2/keymat_v2.c 第540-565行
METHOD(keymat_v2_t, derive_child_keys, bool,
    private_keymat_v2_t *this, proposal_t *proposal, array_t *kes,
    chunk_t nonce_i, chunk_t nonce_r, chunk_t *encr_i, chunk_t *integ_i,
    chunk_t *encr_r, chunk_t *integ_r)
{
    uint16_t enc_alg, int_alg, enc_size = 0, int_size = 0;
    
    // 1. 获取ESP加密算法（国密改造点）
    if (proposal->get_algorithm(proposal, ENCRYPTION_ALGORITHM,
                                &enc_alg, &enc_size))
    {
        DBG2(DBG_CHD, "  using %N for encryption",
             encryption_algorithm_names, enc_alg);
        // enc_alg 可能是 ENCR_SM4_CBC 或 ENCR_SM4_GCM_ICV16
        // enc_size 对于SM4固定是128位
    }
    
    // 2. 获取ESP完整性算法（仅非AEAD模式需要）
    if (proposal->get_algorithm(proposal, INTEGRITY_ALGORITHM,
                                &int_alg, NULL))
    {
        DBG2(DBG_CHD, "  using %N for integrity protection",
             integrity_algorithm_names, int_alg);
        // int_alg 可能是 AUTH_HMAC_SM3_128
    }
    
    // 3. 使用PRF-HMAC-SM3派生ESP密钥
    // 使用存储的SK_d（由derive_ike_keys生成）
    prf_plus = lib->crypto->create_kdf(lib->crypto, KDF_PRF_PLUS, this->prf_alg);
    if (!prf_plus->set_param(prf_plus, KDF_PARAM_KEY, this->skd) ||
        !prf_plus->set_param(prf_plus, KDF_PARAM_SALT, seed))
    {
        DESTROY_IF(prf_plus);
        return FALSE;
    }
    
    // 4. 派生密钥材料：encr_i | integ_i | encr_r | integ_r
    keymat.len = 2 * enc_size + 2 * int_size;
    if (!prf_plus->allocate_bytes(prf_plus, keymat.len, &keymat))
    {
        prf_plus->destroy(prf_plus);
        return FALSE;
    }
    
    chunk_split(keymat, "aaaa", enc_size, encr_i, int_size, integ_i,
                enc_size, encr_r, int_size, integ_r);
    
    // encr_i/encr_r: ESP SM4加密密钥（各128位）
    // integ_i/integ_r: ESP HMAC-SM3完整性密钥（各256位）
    DBG4(DBG_CHD, "encryption initiator key %B", encr_i);
    DBG4(DBG_CHD, "encryption responder key %B", encr_r);
    DBG4(DBG_CHD, "integrity initiator key %B", integ_i);
    DBG4(DBG_CHD, "integrity responder key %B", integ_r);
    
    // 这些密钥会被传递给ESP处理模块使用
    return TRUE;
}
```

**内核支持**（Linux）：
```bash
# 检查内核是否支持SM4
grep -r "SM4" /proc/crypto

# 输出示例：
# name         : sm4
# driver       : sm4-generic
# module       : sm4_generic
# type         : cipher
# blocksize    : 16
# min keysize  : 16
# max keysize  : 16
```

---

#### 场景6：ESP完整性保护
**用途**：验证数据包未被篡改

**当前使用的算法**：
- HMAC-SHA1-96
- HMAC-SHA2-256-128
- HMAC-SHA2-384-192
- HMAC-SHA2-512-256
- AES-XCBC-96

**国密替代方案**：
```
HMAC-SHA1-96       →  HMAC-SM3-96 (或128)
HMAC-SHA2-256-128  →  HMAC-SM3-128
AES-XCBC-96        →  SM4-XCBC-96 (需实现)
```

---

### 1.3 认证阶段

#### 场景7：数字签名
**用途**：验证通信双方身份

**当前使用的算法**：
- RSA-SHA1
- RSA-SHA256
- RSA-SHA384
- RSA-SHA512
- ECDSA-SHA256
- ECDSA-SHA384
- ECDSA-SHA512
- EdDSA (Ed25519)

**国密替代方案**：
```
RSA-SHA256        →  SM2-SM3
RSA-SHA384        →  SM2-SM3
RSA-SHA512        →  SM2-SM3
ECDSA-SHA256      →  SM2-SM3
ECDSA-SHA384      →  SM2-SM3
EdDSA             →  SM2-SM3
```

**代码位置**：
```
src/libstrongswan/credentials/keys/public_key.h    # 签名算法定义
src/libcharon/sa/ikev2/authenticators/          # 认证器实现
src/libcharon/sa/ikev2/authenticators/pubkey_authenticator.c  # 公钥认证具体实现
```

**详细代码调用链**：

**选择签名方案**（src/libcharon/sa/ikev2/authenticators/pubkey_authenticator.c 第157-240行）：
```c
// 根据配置、对端能力和私钥类型选择签名方案
static array_t *select_signature_schemes(keymat_v2_t *keymat,
                                    auth_cfg_t *auth, private_key_t *private)
{
    enumerator_t *enumerator;
    signature_params_t *config;
    key_type_t key_type;
    array_t *supported = NULL, *selected;

    selected = array_create(0, 0);
    key_type = private->get_type(private);  // 可能返回 KEY_RSA, KEY_ECDSA, KEY_SM2

    // 1. 获取私钥支持的签名方案列表（国密改造点：SM2密钥需支持）
    if (private->supported_signature_schemes)
    {
        enumerator = private->supported_signature_schemes(private);
        while (enumerator->enumerate(enumerator, &config))
        {
            // 检查对端是否支持此哈希算法
            if (keymat->hash_algorithm_supported(keymat,
                        hasher_from_signature_scheme(config->scheme,
                                                     config->params)))
            {
                // 对于SM2私钥，这里会返回 SIGN_SM2_WITH_SM3
                array_insert_create(&supported, ARRAY_TAIL,
                                    signature_params_clone(config));
            }
        }
        enumerator->destroy(enumerator);
    }

    // 2. 根据配置文件选择签名方案
    enumerator = auth->create_enumerator(auth);
    while (enumerator->enumerate(enumerator, &rule, &config))
    {
        if (rule != AUTH_RULE_IKE_SIGNATURE_SCHEME)
        {
            continue;
        }
        // 检查密钥类型是否匹配（国密改造点）
        // key_type_from_signature_scheme(SIGN_SM2_WITH_SM3) 应返回 KEY_SM2
        if (key_type == key_type_from_signature_scheme(config->scheme) &&
            keymat->hash_algorithm_supported(keymat,
                        hasher_from_signature_scheme(config->scheme,
                                                     config->params)))
        {
            add_scheme_if_supported(selected, supported, config);
        }
    }
    enumerator->destroy(enumerator);
    
    return selected;
}
```

**生成签名**（RFC 7427方式，第310-400行）：
```c
// 使用选定的签名方案生成认证数据
METHOD(authenticator_t, build, status_t,
    private_pubkey_authenticator_t *this, message_t *message)
{
    enumerator_t *enumerator;
    signature_params_t *params;
    private_key_t *private;
    identification_t *id;
    auth_cfg_t *auth;
    chunk_t octets = chunk_empty, auth_data;
    status_t status = NOT_FOUND;
    keymat_v2_t *keymat;
    array_t *schemes;

    // 1. 获取私钥
    private = this->ike_sa->get_private_key(this->ike_sa);
    if (!private)
    {
        DBG1(DBG_IKE, "no private key found for '%Y'", id);
        return NOT_FOUND;
    }

    // 2. 选择可用的签名方案
    keymat = (keymat_v2_t*)this->ike_sa->get_keymat(this->ike_sa);
    auth = this->ike_sa->get_auth_cfg(this->ike_sa, TRUE);
    schemes = select_signature_schemes(keymat, auth, private);
    // 对于SM2密钥，schemes可能包含 SIGN_SM2_WITH_SM3

    // 3. 获取待签名数据（使用PRF-HMAC-SM3派生）
    if (!keymat->get_auth_octets(keymat, FALSE, this->ike_sa_init,
                                 this->nonce, this->int_auth, this->ppk,
                                 id, this->reserved, &octets, schemes))
    {
        chunk_free(&octets);
        return FAILED;
    }

    // 4. 遍历可用方案，尝试签名
    enumerator = array_create_enumerator(schemes);
    while (enumerator->enumerate(enumerator, &params))
    {
        // 使用私钥签名（国密改造点：SM2私钥需实现sign方法）
        // params->scheme 可能是 SIGN_SM2_WITH_SM3
        // params->params 可能是 NULL（SM2不需要额外参数）
        if (private->sign(private, params->scheme, params->params,
                         octets, &auth_data))
        {
            // 5. 构建AUTH载荷（RFC 7427格式）
            // auth_data前面需要添加签名方案标识
            if (!build_signature_auth_data(&auth_data, params))
            {
                chunk_free(&auth_data);
                status = FAILED;
                break;
            }
            
            // 6. 添加到IKE消息中
            add_auth_to_message(message, AUTH_DS, auth_data, FALSE);
            status = SUCCESS;
            
            // 7. 记录日志
            DBG1(DBG_IKE, "authentication of '%Y' (myself) with %N successful",
                 id, signature_scheme_names, params->scheme);
            // 输出可能是：authentication of 'CN=vpn-server' with SM2_WITH_SM3 successful
            break;
        }
    }
    enumerator->destroy(enumerator);
    
    return status;
}
```

**验证签名**（第570-700行）：
```c
// 验证对端的签名
METHOD(authenticator_t, process, status_t,
    private_pubkey_authenticator_t *this, message_t *message)
{
    public_key_t *public;
    auth_payload_t *auth_payload;
    chunk_t auth_data, octets;
    signature_params_t *params;
    auth_method_t auth_method;
    key_type_t key_type = KEY_ANY;
    identification_t *id;
    auth_cfg_t *auth, *current_auth;
    enumerator_t *enumerator;
    status_t status = NOT_FOUND;
    keymat_v2_t *keymat;

    // 1. 获取AUTH载荷
    auth_payload = (auth_payload_t*)message->get_payload(message, PLV2_AUTH);
    if (!auth_payload)
    {
        return NOT_FOUND;
    }
    
    auth_method = auth_payload->get_auth_method(auth_payload);
    auth_data = auth_payload->get_data(auth_payload);

    // 2. 解析签名方案（RFC 7427格式）
    INIT(params);
    if (auth_method == AUTH_DS)  // 数字签名方法
    {
        // 从auth_data中提取签名方案和实际签名
        if (!parse_signature_auth_data(&auth_data, &key_type, params))
        {
            DBG1(DBG_IKE, "failed to parse signature authentication data");
            signature_params_destroy(params);
            return INVALID_ARG;
        }
        // key_type 可能是 KEY_SM2
        // params->scheme 可能是 SIGN_SM2_WITH_SM3
    }

    // 3. 获取对端的公钥
    id = this->ike_sa->get_other_id(this->ike_sa);
    keymat = (keymat_v2_t*)this->ike_sa->get_keymat(this->ike_sa);
    
    current_auth = this->ike_sa->get_auth_cfg(this->ike_sa, FALSE);
    enumerator = lib->credmgr->create_public_enumerator(lib->credmgr,
                                                        key_type, id, current_auth, TRUE);
    while (enumerator->enumerate(enumerator, &public, &auth))
    {
        // 4. 获取待验证数据（使用PRF-HMAC-SM3派生）
        if (!get_auth_octets_scheme(this, TRUE, id, this->ppk, &octets, &params))
        {
            continue;
        }

        // 5. 使用公钥验证签名（国密改造点：SM2公钥需实现verify方法）
        // public 是 SM2公钥对象
        // params->scheme 是 SIGN_SM2_WITH_SM3
        if (public->verify(public, params->scheme, params->params,
                          octets, auth_data))
        {
            DBG1(DBG_IKE, "authentication of '%Y' with %N successful",
                 id, signature_scheme_names, params->scheme);
            // 输出可能是：authentication of 'CN=vpn-client' with SM2_WITH_SM3 successful
            
            status = SUCCESS;
            auth->merge(auth, current_auth, FALSE);
            this->ike_sa->set_auth_cfg(this->ike_sa, FALSE, auth);
            chunk_free(&octets);
            break;
        }
        else
        {
            DBG2(DBG_IKE, "signature verification with %N key failed",
                 key_type_names, public->get_type(public));
            status = FAILED;
        }
        chunk_free(&octets);
    }
    enumerator->destroy(enumerator);

    signature_params_destroy(params);
    return status;
}
```

**SM2私钥sign方法需要实现**（在gmsm_private_key.c中）：
```c
METHOD(private_key_t, sign, bool,
    private_gmsm_private_key_t *this, signature_scheme_t scheme,
    void *params, chunk_t data, chunk_t *signature)
{
    uint8_t hash[HASH_SIZE_SM3];
    chunk_t dgst;
    
    // 1. 检查签名方案
    if (scheme != SIGN_SM2_WITH_SM3 && scheme != SIGN_SM2_WITH_NULL)
    {
        DBG1(DBG_LIB, "signature scheme %N not supported by SM2",
             signature_scheme_names, scheme);
        return FALSE;
    }
    
    // 2. 对数据进行SM3哈希（如果需要）
    if (scheme == SIGN_SM2_WITH_SM3)
    {
        hasher_t *hasher = lib->crypto->create_hasher(lib->crypto, HASH_SM3);
        if (!hasher)
        {
            return FALSE;
        }
        if (!hasher->get_hash(hasher, data, hash))
        {
            hasher->destroy(hasher);
            return FALSE;
        }
        hasher->destroy(hasher);
        dgst = chunk_from_thing(hash);
    }
    else
    {
        dgst = data;  // 数据已经是哈希值
    }
    
    // 3. 使用SM2算法签名
    // 调用底层SM2签名函数（如GmSSL、OpenSSL 3.0等）
    if (!sm2_sign(this->ec_key, dgst.ptr, dgst.len, 
                  signature->ptr, &signature->len))
    {
        return FALSE;
    }
    
    return TRUE;
}
```

**SM2公钥verify方法需要实现**（在gmsm_public_key.c中）：
```c
METHOD(public_key_t, verify, bool,
    private_gmsm_public_key_t *this, signature_scheme_t scheme,
    void *params, chunk_t data, chunk_t signature)
{
    uint8_t hash[HASH_SIZE_SM3];
    chunk_t dgst;
    
    // 1. 检查签名方案
    if (scheme != SIGN_SM2_WITH_SM3 && scheme != SIGN_SM2_WITH_NULL)
    {
        DBG1(DBG_LIB, "signature scheme %N not supported by SM2",
             signature_scheme_names, scheme);
        return FALSE;
    }
    
    // 2. 对数据进行SM3哈希（如果需要）
    if (scheme == SIGN_SM2_WITH_SM3)
    {
        hasher_t *hasher = lib->crypto->create_hasher(lib->crypto, HASH_SM3);
        if (!hasher)
        {
            return FALSE;
        }
        if (!hasher->get_hash(hasher, data, hash))
        {
            hasher->destroy(hasher);
            return FALSE;
        }
        hasher->destroy(hasher);
        dgst = chunk_from_thing(hash);
    }
    else
    {
        dgst = data;
    }
    
    // 3. 使用SM2算法验证签名
    // 调用底层SM2验证函数
    return sm2_verify(this->ec_key, dgst.ptr, dgst.len,
                      signature.ptr, signature.len);
}
```

---

#### 场景8：证书哈希
**用途**：计算证书指纹、证书链验证

**当前使用的算法**：
- SHA1
- SHA256
- SHA384
- SHA512

**国密替代方案**：
```
SHA1      →  SM3
SHA256    →  SM3
SHA384    →  SM3
SHA512    →  SM3
```

**代码位置**：
```
src/libstrongswan/credentials/certificates/certificate.c  # 证书基础接口
src/libstrongswan/plugins/x509/x509_cert.c                # X.509证书实现
src/libstrongswan/credentials/certificates/x509.h         # X.509证书接口
```

**详细代码调用链**：

**证书签名验证**（src/libstrongswan/plugins/x509/x509_cert.c 第1718-1778行）：
```c
// 验证证书是否由指定的CA签发
METHOD(certificate_t, issued_by, bool,
    private_x509_cert_t *this, certificate_t *issuer,
    signature_params_t **scheme)
{
    public_key_t *key;
    bool valid;
    x509_t *x509 = (x509_t*)issuer;
    chunk_t keyid = chunk_empty;

    // 1. 检查是否是自签名证书
    if (&this->public.interface.interface == issuer)
    {
        if (this->flags & X509_SELF_SIGNED)
        {
            if (scheme)
            {
                *scheme = signature_params_clone(this->scheme);
            }
            return TRUE;
        }
    }
    else
    {
        // 2. 验证issuer类型和CA标志
        if (issuer->get_type(issuer) != CERT_X509)
        {
            return FALSE;
        }
        if (!(x509->get_flags(x509) & X509_CA))
        {
            return FALSE;
        }
    }

    // 3. 比较密钥标识符（如果存在）
    // 检查证书的authKeyIdentifier是否匹配CA的subjectKeyIdentifier
    if (this->authKeyIdentifier.ptr)
    {
        keyid = x509->get_subjectKeyIdentifier(x509);
        if (keyid.len && !chunk_equals(keyid, this->authKeyIdentifier))
        {
            return FALSE;
        }
    }
    
    // 4. 比较DN（如果没有密钥标识符）
    if (!keyid.len)
    {
        if (!this->issuer->equals(this->issuer, issuer->get_subject(issuer)))
        {
            return FALSE;
        }
    }

    // 5. 获取CA证书的公钥
    key = issuer->get_public_key(issuer);
    if (!key)
    {
        return FALSE;
    }
    
    // 6. 验证证书签名（国密改造点：需要支持SM2公钥和SM3哈希）
    // this->scheme->scheme 可能是 SIGN_RSA_EMSA_PKCS1_SHA256 或 SIGN_SM2_WITH_SM3
    // this->scheme->params 对于SM2通常是NULL
    // this->tbsCertificate 是待验证的TBSCertificate部分
    // this->signature 是证书的签名值
    valid = key->verify(key, this->scheme->scheme, this->scheme->params,
                        this->tbsCertificate, this->signature);
    key->destroy(key);
    
    if (valid && scheme)
    {
        // 返回使用的签名方案
        *scheme = signature_params_clone(this->scheme);
    }
    return valid;
}
```

**证书解析时提取签名算法**（x509_cert.c 第1200-1400行附近）：
```c
// 解析证书时提取签名算法OID
static bool parse_certificate(private_x509_cert_t *this, chunk_t blob)
{
    // ...解析ASN.1结构...
    
    // 从证书中提取signatureAlgorithm字段
    if (!asn1_parse_algorithmIdentifier(sig_alg, level, NULL))
    {
        goto end;
    }
    
    // 将OID转换为签名方案（国密改造点）
    // 需要在oid.c中添加SM2算法OID的映射
    this->scheme = signature_params_parse(sig_alg, level);
    if (!this->scheme)
    {
        goto end;
    }
    
    // this->scheme->scheme 可能是：
    // - SIGN_RSA_EMSA_PKCS1_SHA256 (OID 1.2.840.113549.1.1.11)
    // - SIGN_ECDSA_WITH_SHA256     (OID 1.2.840.10045.4.3.2)
    // - SIGN_SM2_WITH_SM3          (OID 1.2.156.10197.1.501) [国密新增]
    
    // ...继续解析证书其他部分...
}
```

**签名算法OID映射**（需要在src/libstrongswan/asn1/oid.c中添加）：
```c
// src/libstrongswan/asn1/oid.c
const oid_t oid_names[] = {
    // ...现有OID定义...
    
    // 国密算法OID（需要添加）
    {OID_SM3,                    // 1.2.156.10197.1.401
        HASH_SM3,               "sm3"},
    {OID_SM2,                    // 1.2.156.10197.1.301
        KEY_SM2,                "sm2"},
    {OID_SM2_WITH_SM3,          // 1.2.156.10197.1.501
        SIGN_SM2_WITH_SM3,      "sm2WithSM3"},
    {OID_SM4_CBC,               // 1.2.156.10197.1.104.2
        ENCR_SM4_CBC,           "sm4-cbc"},
    
    // ...
};

// OID到签名方案的转换
signature_scheme_t signature_scheme_from_oid(int oid)
{
    switch (oid)
    {
        case OID_MD5_WITH_RSA:
            return SIGN_RSA_EMSA_PKCS1_MD5;
        case OID_SHA1_WITH_RSA:
            return SIGN_RSA_EMSA_PKCS1_SHA1;
        case OID_SHA256_WITH_RSA:
            return SIGN_RSA_EMSA_PKCS1_SHA2_256;
        case OID_ECDSA_WITH_SHA256:
            return SIGN_ECDSA_256;
        // 国密新增
        case OID_SM2_WITH_SM3:
            return SIGN_SM2_WITH_SM3;
        default:
            return SIGN_UNKNOWN;
    }
}
```

**证书链验证流程**（在charon中调用）：
```c
// src/libstrongswan/credentials/cert_validator.c
// 验证整个证书链
bool validate_certificate_chain(certificate_t *subject, certificate_t **issuer_out)
{
    enumerator_t *enumerator;
    certificate_t *issuer;
    bool valid = FALSE;
    
    // 1. 从证书存储中查找可能的颁发者
    enumerator = lib->credmgr->create_cert_enumerator(lib->credmgr,
                        CERT_X509, KEY_ANY, subject->get_issuer(subject), TRUE);
    
    while (enumerator->enumerate(enumerator, &issuer))
    {
        signature_params_t *scheme = NULL;
        
        // 2. 验证签名（国密改造点：这里会调用SM2公钥的verify方法）
        if (subject->issued_by(subject, issuer, &scheme))
        {
            // 签名验证成功
            DBG1(DBG_CFG, "  certificate signed by '%Y' with %N",
                 issuer->get_subject(issuer),
                 signature_scheme_names, scheme->scheme);
            // 可能输出：certificate signed by 'CN=My CA' with SM2_WITH_SM3
            
            // 3. 检查证书有效期
            if (!issuer->get_validity(issuer, NULL, NULL, NULL))
            {
                DBG1(DBG_CFG, "  issuer certificate is not valid");
                signature_params_destroy(scheme);
                continue;
            }
            
            // 4. 递归验证CA证书
            if (!(x509->get_flags(x509) & X509_SELF_SIGNED))
            {
                valid = validate_certificate_chain(issuer, NULL);
            }
            else
            {
                valid = TRUE;  // 到达信任锚点
            }
            
            signature_params_destroy(scheme);
            if (valid)
            {
                *issuer_out = issuer->get_ref(issuer);
                break;
            }
        }
    }
    enumerator->destroy(enumerator);
    
    return valid;
}
```

**证书指纹计算**（使用SM3哈希）：
```c
// src/libstrongswan/credentials/certificates/certificate.c
METHOD(certificate_t, get_fingerprint, bool,
    certificate_t *this, cred_encoding_type_t type, chunk_t *fp)
{
    hasher_t *hasher;
    hash_algorithm_t hash_alg;
    
    // 根据编码类型选择哈希算法
    switch (type)
    {
        case CERT_PGP_SHA1:
        case CERT_SPKI_SHA1:
            hash_alg = HASH_SHA1;
            break;
        case CERT_SPKI_SHA256:
            hash_alg = HASH_SHA256;
            break;
        // 国密新增
        case CERT_SPKI_SM3:
            hash_alg = HASH_SM3;
            break;
        default:
            return FALSE;
    }
    
    // 创建哈希器（国密改造点：需要支持SM3）
    hasher = lib->crypto->create_hasher(lib->crypto, hash_alg);
    if (!hasher)
    {
        DBG1(DBG_LIB, "%N hash algorithm not supported",
             hash_algorithm_names, hash_alg);
        return FALSE;
    }
    
    // 计算证书指纹
    chunk_t encoding = this->get_encoding(this);
    if (!hasher->allocate_hash(hasher, encoding, fp))
    {
        hasher->destroy(hasher);
        return FALSE;
    }
    hasher->destroy(hasher);
    
    return TRUE;
}
```

**证书加载时的公钥提取**（x509_cert.c中）：
```c
// 从证书中提取公钥
static public_key_t *parse_public_key(chunk_t blob)
{
    // 解析SubjectPublicKeyInfo
    // ...
    
    // 根据算法OID创建公钥对象
    switch (algorithm)
    {
        case OID_RSA_ENCRYPTION:
            return lib->creds->create(lib->creds, CRED_PUBLIC_KEY, KEY_RSA,
                                     BUILD_BLOB_ASN1_DER, blob, BUILD_END);
        case OID_EC_PUBLICKEY:
            return lib->creds->create(lib->creds, CRED_PUBLIC_KEY, KEY_ECDSA,
                                     BUILD_BLOB_ASN1_DER, blob, BUILD_END);
        // 国密新增
        case OID_SM2:
            return lib->creds->create(lib->creds, CRED_PUBLIC_KEY, KEY_SM2,
                                     BUILD_BLOB_ASN1_DER, blob, BUILD_END);
        default:
            DBG1(DBG_LIB, "unsupported public key algorithm %d", algorithm);
            return NULL;
    }
}
```

---

## 2. IPsec/IKE协议中的加密算法使用场景

### 2.1 IKE协商阶段（IKE_SA）

| 场景 | 国际算法 | 密钥长度 | 国密算法 | 密钥长度 | 优先级 |
|------|----------|----------|----------|----------|--------|
| IKE加密 | AES-CBC | 128/192/256 | SM4-CBC | 128 | 高 |
| IKE加密(AEAD) | AES-GCM | 128/192/256 | SM4-GCM | 128 | 高 |
| ESP加密 | AES-CBC | 128/192/256 | SM4-CBC | 128 | 高 |
| ESP加密 | AES-CTR | 128/192/256 | SM4-CTR | 128 | 中 |
| ESP加密(AEAD) | AES-GCM | 128/192/256 | SM4-GCM | 128 | 高 |
| 密钥包裹 | AES-KEYWRAP | 128/256 | SM4-KEYWRAP | 128 | 中 |

**实现建议**：
```c
// 在proposal中添加SM4算法
// src/libstrongswan/crypto/proposal/proposal_keywords_static.txt
sm4,         ENCRYPTION_ALGORITHM, ENCR_SM4_CBC,      128
sm4cbc,      ENCRYPTION_ALGORITHM, ENCR_SM4_CBC,      128
sm4ctr,      ENCRYPTION_ALGORITHM, ENCR_SM4_CTR,      128
sm4gcm,      ENCRYPTION_ALGORITHM, ENCR_SM4_GCM,      128
sm4gcm16,    ENCRYPTION_ALGORITHM, ENCR_SM4_GCM_ICV16, 128
```

---

### 2.2 哈希算法映射表

| 场景 | 国际算法 | 输出长度 | 国密算法 | 输出长度 | 优先级 |
|------|----------|----------|----------|----------|--------|
| 消息摘要 | SHA-256 | 256位 | SM3 | 256位 | 高 |
| 消息摘要 | SHA-384 | 384位 | SM3 | 256位 | 中 |
| 消息摘要 | SHA-512 | 512位 | SM3 | 256位 | 中 |
| 证书指纹 | SHA-256 | 256位 | SM3 | 256位 | 高 |
| PRF | SHA-256 | 256位 | SM3 | 256位 | 高 |

**实现建议**：
```c
// src/libstrongswan/crypto/hashers/hasher.h
enum hash_algorithm_t {
    HASH_SHA3_512 = 1031,
    HASH_SM3 = 1032,  // 新增
};

#define HASH_SIZE_SM3 32
```

---

### 2.3 完整性算法映射表

| 场景 | 国际算法 | 输出长度 | 国密算法 | 输出长度 | 优先级 |
|------|----------|----------|----------|----------|--------|
| IKE完整性 | HMAC-SHA256-128 | 128位 | HMAC-SM3-128 | 128位 | 高 |
| IKE完整性 | HMAC-SHA256-256 | 256位 | HMAC-SM3-256 | 256位 | 中 |
| ESP完整性 | HMAC-SHA256-128 | 128位 | HMAC-SM3-128 | 128位 | 高 |
| AH完整性 | HMAC-SHA256 | 256位 | HMAC-SM3 | 256位 | 高 |

**实现建议**：
```c
// src/libstrongswan/crypto/signers/signer.h
enum integrity_algorithm_t {
    AUTH_HMAC_SHA2_512_256 = 14,
    AUTH_HMAC_SM3_128 = 1032,  // 新增
    AUTH_HMAC_SM3_256 = 1033,  // 新增
};
```

---

### 2.4 公钥算法映射表

| 场景 | 国际算法 | 密钥长度 | 国密算法 | 密钥长度 | 优先级 |
|------|----------|----------|----------|----------|--------|
| 数字签名 | RSA-2048 | 2048位 | SM2 | 256位 | 高 |
| 数字签名 | ECDSA-P256 | 256位 | SM2 | 256位 | 高 |
| 密钥交换 | ECDH-P256 | 256位 | SM2-DH | 256位 | 高 |
| 密钥交换 | DH-2048 | 2048位 | SM2-DH | 256位 | 中 |
| 证书公钥 | RSA | 2048/4096 | SM2 | 256位 | 高 |
| 证书公钥 | ECDSA | 256/384 | SM2 | 256位 | 高 |

**实现建议**：
```c
// src/libstrongswan/credentials/keys/public_key.h
enum key_type_t {
    KEY_ED448 = 5,
    KEY_SM2 = 6,  // 新增
};

enum signature_scheme_t {
    SIGN_ED448,
    SIGN_SM2_WITH_SM3,    // 新增：SM2签名配合SM3哈希
    SIGN_SM2_WITH_NULL,   // 新增：SM2签名（用于预哈希数据）
};
```

---

## 3. 国际算法与国密算法对应关系

### 3.1 对称加密算法映射表

#### 3.1.1 IKE提案配置

**位置**：`/etc/swanctl/swanctl.conf`

**修改前（使用AES）**：
```yaml
connections {
    my-connection {
        proposals = aes256-sha256-modp2048
        # 等价于：
        # encryption: AES-CBC-256
        # integrity: HMAC-SHA2-256-128
        # dh-group: MODP-2048
    }
}
```

**修改后（使用国密）**：
```yaml
connections {
    my-connection {
        proposals = sm4-sm3-sm2dh
        # 等价于：
        # encryption: SM4-CBC-128
        # integrity: HMAC-SM3-128
        # dh-group: SM2-DH (需要在代码中实现)
    }
}
```

**混合配置（同时支持国密和国际算法）**：
```yaml
connections {
    my-connection {
        # 优先使用国密，回退到AES
        proposals = sm4-sm3-sm2dh,aes256-sha256-modp2048
    }
}
```

---

#### 3.1.2 ESP提案配置

**修改前**：
```yaml
children {
    my-child {
        esp_proposals = aes256-sha256
    }
}
```

**修改后**：
```yaml
children {
    my-child {
        esp_proposals = sm4-sm3
        # 或使用AEAD模式
        esp_proposals = sm4gcm16
    }
}
```

---

#### 3.1.3 认证配置

**修改前（使用RSA证书）**：
```yaml
local {
    auth = pubkey
    certs = my-rsa-cert.pem  # RSA证书
    id = "C=CN, O=MyOrg, CN=vpn.example.com"
}
```

**修改后（使用SM2证书）**：
```yaml
local {
    auth = pubkey
    certs = my-sm2-cert.pem  # SM2证书
    id = "C=CN, O=MyOrg, CN=vpn.example.com"
}
```

---

### 3.2 代码修改位置详解

#### 3.2.1 算法枚举添加

**文件1**：`src/libstrongswan/crypto/crypters/crypter.h`
```c
enum encryption_algorithm_t {
    // ... 现有算法
    ENCR_CHACHA20_POLY1305 = 28,
    ENCR_UNDEFINED = 1024,
    
    // 在私有范围添加国密算法
    ENCR_SM4_CBC = 1031,
    ENCR_SM4_ECB = 1032,
    ENCR_SM4_CTR = 1033,
    ENCR_SM4_GCM_ICV16 = 1034,
    ENCR_SM4_GCM_ICV12 = 1035,
    ENCR_SM4_GCM_ICV8 = 1036,
    ENCR_SM4_CCM_ICV16 = 1037,
};
```

**文件2**：`src/libstrongswan/crypto/crypters/crypter.c`
```c
ENUM_BEGIN(encryption_algorithm_names, ENCR_DES_IV64, ENCR_NULL,
    "DES_IV64",
    // ... 其他算法
    "NULL");
// 添加SM4算法名称
ENUM_NEXT(encryption_algorithm_names, ENCR_SM4_CBC, ENCR_SM4_CCM_ICV16, 
    ENCR_NULL,
    "SM4_CBC",
    "SM4_ECB",
    "SM4_CTR",
    "SM4_GCM_16",
    "SM4_GCM_12",
    "SM4_GCM_8",
    "SM4_CCM_16");
ENUM_END(encryption_algorithm_names, ENCR_SM4_CCM_ICV16);
```

---

#### 3.2.2 算法注册

**文件**：`src/libstrongswan/plugins/gmsm/gmsm_plugin.c`
```c
METHOD(plugin_t, get_features, int,
    private_gmsm_plugin_t *this, plugin_feature_t *features[])
{
    static plugin_feature_t f[] = {
        // 注册SM4加密器
        PLUGIN_REGISTER(CRYPTER, gmsm_crypter_create),
            PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_CBC, 16),
            PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_ECB, 16),
            PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_CTR, 16),
            PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_GCM_ICV16, 16),
            
        // 注册SM3哈希
        PLUGIN_REGISTER(HASHER, gmsm_hasher_create),
            PLUGIN_PROVIDE(HASHER, HASH_SM3),
            
        // 注册HMAC-SM3
        PLUGIN_REGISTER(SIGNER, gmsm_signer_create),
            PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_SM3_128),
            PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_SM3_256),
            
        // 注册SM2密钥
        PLUGIN_REGISTER(PUBKEY, gmsm_public_key_load, TRUE),
            PLUGIN_PROVIDE(PUBKEY, KEY_SM2),
        PLUGIN_REGISTER(PRIVKEY, gmsm_private_key_load, TRUE),
            PLUGIN_PROVIDE(PRIVKEY, KEY_SM2),
            
        // 注册SM2签名
        PLUGIN_PROVIDE(PRIVKEY_SIGN, SIGN_SM2_WITH_SM3),
        PLUGIN_PROVIDE(PUBKEY_VERIFY, SIGN_SM2_WITH_SM3),
    };
    *features = f;
    return countof(f);
}
```

---

#### 3.2.3 IKE密钥派生修改

**文件**：`src/libcharon/sa/ikev2/keymat_v2.c`

**修改点1：PRF选择**
```c
METHOD(keymat_v2_t, derive_ike_keys, bool,
    private_keymat_v2_t *this, proposal_t *proposal, ...)
{
    pseudo_random_function_t prf_alg;
    
    // 从提案中获取PRF算法
    prf_alg = proposal->get_algorithm(proposal, PSEUDO_RANDOM_FUNCTION, 
                                     NULL, NULL);
    
    // 这里可能返回 PRF_HMAC_SM3（如果配置了国密）
    this->prf = lib->crypto->create_prf(lib->crypto, prf_alg);
    
    if (!this->prf)
    {
        DBG1(DBG_IKE, "negotiated %N not supported!",
             pseudo_random_function_names, prf_alg);
        return FALSE;
    }
}
```

**修改点2：加密算法选择**
```c
METHOD(keymat_v2_t, derive_child_keys, bool,
    private_keymat_v2_t *this, proposal_t *proposal, ...)
{
    encryption_algorithm_t enc_alg;
    size_t enc_size;
    
    // 获取ESP加密算法
    enc_alg = proposal->get_algorithm(proposal, ENCRYPTION_ALGORITHM, 
                                     &enc_size, NULL);
    
    // 这里可能返回 ENCR_SM4_CBC（如果配置了国密）
    // enc_size会是128位
}
```

---

#### 3.2.4 ESP数据包处理

**文件**：`src/libipsec/esp_packet.c`

**加密路径**：
```c
METHOD(esp_packet_t, encrypt, status_t,
    private_esp_packet_t *this, u_int32_t spi, u_int64_t seq,
    crypter_t *crypter, signer_t *signer)
{
    // crypter可能是SM4实例
    // signer可能是HMAC-SM3实例
    
    chunk_t payload;
    
    // 填充
    // ...
    
    // 加密（这里会调用SM4的encrypt方法）
    if (!crypter->encrypt(crypter, payload, iv, NULL))
    {
        return FAILED;
    }
    
    // 计算ICV（这里会调用HMAC-SM3）
    if (signer)
    {
        signer->get_signature(signer, this->packet->get_data(this->packet),
                             icv);
    }
}
```

---

#### 3.2.5 证书验证

**文件**：`src/libstrongswan/credentials/certificates/x509.c`

**修改点：证书签名验证**
```c
METHOD(certificate_t, issued_by, bool,
    private_x509_t *this, certificate_t *issuer, 
    signature_params_t **scheme)
{
    public_key_t *key = issuer->get_public_key(issuer);
    signature_scheme_t sig_scheme;
    chunk_t tbs;
    
    // 获取证书的签名算法
    // 如果是SM2证书，这里会返回SIGN_SM2_WITH_SM3
    sig_scheme = signature_scheme_from_oid(this->signature_algorithm);
    
    // 验证签名
    tbs = asn1_wrap(ASN1_SEQUENCE, "mm",
                   asn1_wrap(ASN1_SEQUENCE, "cc",
                            asn1_simple_object(ASN1_OID, 
                                             this->tbsCertificate),
                            this->tbsCertificateSeq),
                   this->signature);
    
    // 这里会调用SM2公钥的verify方法
    valid = key->verify(key, sig_scheme, NULL, tbs, this->signature);
    
    key->destroy(key);
    return valid;
}
```

---

## 4. 具体修改位置和方法

### 4.1 使用GmSSL的完整实现示例

#### 4.1.1 SM4加密器实现（gmssl_crypter.c）

**完整代码示例**：
```c
/*
 * SM4加密器实现 - 基于GmSSL库
 */
#include "gmssl_crypter.h"

#include <gmssl/sm4.h>
#include <library.h>
#include <utils/debug.h>

typedef struct private_gmssl_crypter_t private_gmssl_crypter_t;

struct private_gmssl_crypter_t {
    crypter_t public;
    encryption_algorithm_t algorithm;
    size_t key_size;
    
    // GmSSL的密钥结构
    SM4_KEY encrypt_key;
    SM4_KEY decrypt_key;
};

METHOD(crypter_t, decrypt, bool,
    private_gmssl_crypter_t *this, chunk_t data, chunk_t iv,
    chunk_t *decrypted)
{
    uint8_t *in, *out;
    uint8_t iv_copy[16];
    
    if (data.len % 16 != 0)
    {
        return FALSE;
    }
    
    in = data.ptr;
    out = decrypted ? decrypted->ptr : data.ptr;
    memcpy(iv_copy, iv.ptr, sizeof(iv_copy));
    
    switch (this->algorithm)
    {
        case ENCR_SM4_CBC:
            SM4_cbc_encrypt(in, out, data.len, &this->decrypt_key, 
                           iv_copy, 0);  // 0表示解密
            break;
        case ENCR_SM4_ECB:
            for (size_t i = 0; i < data.len; i += 16)
            {
                SM4_decrypt(&this->decrypt_key, in + i, out + i);
            }
            break;
        case ENCR_SM4_CTR:
            // CTR模式加解密相同
            SM4_ctr_encrypt(in, out, data.len, &this->decrypt_key, iv_copy);
            break;
        default:
            return FALSE;
    }
    return TRUE;
}

METHOD(crypter_t, encrypt, bool,
    private_gmssl_crypter_t *this, chunk_t data, chunk_t iv,
    chunk_t *encrypted)
{
    uint8_t *in, *out;
    uint8_t iv_copy[16];
    
    if (data.len % 16 != 0)
    {
        return FALSE;
    }
    
    in = data.ptr;
    out = encrypted ? encrypted->ptr : data.ptr;
    memcpy(iv_copy, iv.ptr, sizeof(iv_copy));
    
    switch (this->algorithm)
    {
        case ENCR_SM4_CBC:
            SM4_cbc_encrypt(in, out, data.len, &this->encrypt_key,
                           iv_copy, 1);  // 1表示加密
            break;
        case ENCR_SM4_ECB:
            for (size_t i = 0; i < data.len; i += 16)
            {
                SM4_encrypt(&this->encrypt_key, in + i, out + i);
            }
            break;
        case ENCR_SM4_CTR:
            SM4_ctr_encrypt(in, out, data.len, &this->encrypt_key, iv_copy);
            break;
        default:
            return FALSE;
    }
    return TRUE;
}

METHOD(crypter_t, get_block_size, size_t,
    private_gmssl_crypter_t *this)
{
    return 16;  // SM4固定16字节分组
}

METHOD(crypter_t, get_iv_size, size_t,
    private_gmssl_crypter_t *this)
{
    switch (this->algorithm)
    {
        case ENCR_SM4_CBC:
        case ENCR_SM4_CTR:
            return 16;
        case ENCR_SM4_ECB:
            return 0;
        default:
            return 0;
    }
}

METHOD(crypter_t, get_key_size, size_t,
    private_gmssl_crypter_t *this)
{
    return this->key_size;
}

METHOD(crypter_t, set_key, bool,
    private_gmssl_crypter_t *this, chunk_t key)
{
    if (key.len != 16)  // SM4只支持128位密钥
    {
        DBG1(DBG_LIB, "SM4 key length must be 128 bits, got %d", key.len * 8);
        return FALSE;
    }
    
    // 使用GmSSL API设置密钥
    SM4_set_encrypt_key(&this->encrypt_key, key.ptr);
    SM4_set_decrypt_key(&this->decrypt_key, key.ptr);
    
    return TRUE;
}

METHOD(crypter_t, destroy, void,
    private_gmssl_crypter_t *this)
{
    // 清除敏感密钥数据
    memwipe(&this->encrypt_key, sizeof(this->encrypt_key));
    memwipe(&this->decrypt_key, sizeof(this->decrypt_key));
    free(this);
}

gmssl_crypter_t *gmssl_crypter_create(encryption_algorithm_t algo,
                                      size_t key_size)
{
    private_gmssl_crypter_t *this;
    
    // 只支持SM4算法
    switch (algo)
    {
        case ENCR_SM4_CBC:
        case ENCR_SM4_ECB:
        case ENCR_SM4_CTR:
            if (key_size != 0 && key_size != 16)
            {
                return NULL;
            }
            break;
        default:
            return NULL;
    }
    
    INIT(this,
        .public = {
            .encrypt = _encrypt,
            .decrypt = _decrypt,
            .get_block_size = _get_block_size,
            .get_iv_size = _get_iv_size,
            .get_key_size = _get_key_size,
            .set_key = _set_key,
            .destroy = _destroy,
        },
        .algorithm = algo,
        .key_size = 16,  // SM4固定128位
    );
    
    return &this->public;
}
```

#### 4.1.2 SM3哈希器实现（gmssl_hasher.c）

```c
/*
 * SM3哈希器实现 - 基于GmSSL库
 */
#include "gmssl_hasher.h"

#include <gmssl/sm3.h>
#include <library.h>

typedef struct private_gmssl_hasher_t private_gmssl_hasher_t;

struct private_gmssl_hasher_t {
    hasher_t public;
    SM3_CTX ctx;
};

METHOD(hasher_t, reset, bool,
    private_gmssl_hasher_t *this)
{
    SM3_init(&this->ctx);
    return TRUE;
}

METHOD(hasher_t, get_hash, bool,
    private_gmssl_hasher_t *this, chunk_t chunk, uint8_t *hash)
{
    SM3_update(&this->ctx, chunk.ptr, chunk.len);
    if (hash)
    {
        SM3_CTX ctx_copy = this->ctx;
        SM3_final(&ctx_copy, hash);
    }
    return TRUE;
}

METHOD(hasher_t, allocate_hash, bool,
    private_gmssl_hasher_t *this, chunk_t chunk, chunk_t *hash)
{
    if (hash)
    {
        *hash = chunk_alloc(HASH_SIZE_SM3);
        get_hash(this, chunk, hash->ptr);
    }
    else
    {
        get_hash(this, chunk, NULL);
    }
    return TRUE;
}

METHOD(hasher_t, get_hash_size, size_t,
    private_gmssl_hasher_t *this)
{
    return HASH_SIZE_SM3;  // 32字节
}

METHOD(hasher_t, destroy, void,
    private_gmssl_hasher_t *this)
{
    memwipe(&this->ctx, sizeof(this->ctx));
    free(this);
}

gmssl_hasher_t *gmssl_hasher_create(hash_algorithm_t algo)
{
    private_gmssl_hasher_t *this;
    
    if (algo != HASH_SM3)
    {
        return NULL;
    }
    
    INIT(this,
        .public = {
            .get_hash = _get_hash,
            .allocate_hash = _allocate_hash,
            .get_hash_size = _get_hash_size,
            .reset = _reset,
            .destroy = _destroy,
        },
    );
    
    SM3_init(&this->ctx);
    
    return &this->public;
}
```

#### 4.1.3 SM2私钥实现（gmssl_private_key.c）

```c
/*
 * SM2私钥实现 - 基于GmSSL库
 */
#include "gmssl_private_key.h"

#include <gmssl/sm2.h>
#include <gmssl/pem.h>
#include <library.h>

typedef struct private_gmssl_private_key_t private_gmssl_private_key_t;

struct private_gmssl_private_key_t {
    private_key_t public;
    SM2_KEY key;
    int ref;
};

METHOD(private_key_t, get_type, key_type_t,
    private_gmssl_private_key_t *this)
{
    return KEY_SM2;
}

METHOD(private_key_t, sign, bool,
    private_gmssl_private_key_t *this, signature_scheme_t scheme,
    void *params, chunk_t data, chunk_t *signature)
{
    uint8_t sig[SM2_MAX_SIGNATURE_SIZE];
    size_t siglen = sizeof(sig);
    
    switch (scheme)
    {
        case SIGN_SM2_WITH_SM3:
            // GmSSL自动进行SM3哈希
            if (!SM2_sign(&this->key,
                         SM2_DEFAULT_ID, strlen(SM2_DEFAULT_ID),
                         data.ptr, data.len,
                         sig, &siglen))
            {
                DBG1(DBG_LIB, "SM2 signature generation failed");
                return FALSE;
            }
            break;
            
        case SIGN_SM2_WITH_NULL:
            // 数据已经是摘要
            if (!SM2_sign_digest(&this->key, data.ptr, sig, &siglen))
            {
                DBG1(DBG_LIB, "SM2 signature generation failed");
                return FALSE;
            }
            break;
            
        default:
            DBG1(DBG_LIB, "signature scheme %N not supported by SM2",
                 signature_scheme_names, scheme);
            return FALSE;
    }
    
    *signature = chunk_clone(chunk_create(sig, siglen));
    return TRUE;
}

METHOD(private_key_t, decrypt, bool,
    private_gmssl_private_key_t *this, encryption_scheme_t scheme,
    chunk_t crypto, chunk_t *plain)
{
    // SM2加密/解密（如果需要）
    uint8_t buf[SM2_MAX_PLAINTEXT_SIZE];
    size_t len = sizeof(buf);
    
    if (!SM2_decrypt(&this->key, crypto.ptr, crypto.len, buf, &len))
    {
        return FALSE;
    }
    
    *plain = chunk_clone(chunk_create(buf, len));
    return TRUE;
}

METHOD(private_key_t, get_keysize, int,
    private_gmssl_private_key_t *this)
{
    return 256;  // SM2固定256位
}

METHOD(private_key_t, get_public_key, public_key_t*,
    private_gmssl_private_key_t *this)
{
    // 从私钥提取公钥
    chunk_t pubkey_der;
    uint8_t buf[1024];
    size_t len = sizeof(buf);
    
    if (!SM2_public_key_to_der(&this->key, buf, &len))
    {
        return NULL;
    }
    
    pubkey_der = chunk_create(buf, len);
    return lib->creds->create(lib->creds, CRED_PUBLIC_KEY, KEY_SM2,
                              BUILD_BLOB_ASN1_DER, pubkey_der,
                              BUILD_END);
}

METHOD(private_key_t, get_encoding, bool,
    private_gmssl_private_key_t *this, cred_encoding_type_t type,
    chunk_t *encoding)
{
    uint8_t buf[1024];
    size_t len = sizeof(buf);
    
    switch (type)
    {
        case PRIVKEY_ASN1_DER:
        case PRIVKEY_PEM:
            if (!SM2_private_key_to_der(&this->key, buf, &len))
            {
                return FALSE;
            }
            *encoding = chunk_clone(chunk_create(buf, len));
            
            if (type == PRIVKEY_PEM)
            {
                chunk_t pem;
                // 转换为PEM格式
                // ... (使用GmSSL的PEM函数)
                chunk_free(encoding);
                *encoding = pem;
            }
            return TRUE;
        default:
            return FALSE;
    }
}

METHOD(private_key_t, destroy, void,
    private_gmssl_private_key_t *this)
{
    if (ref_put(&this->ref))
    {
        memwipe(&this->key, sizeof(this->key));
        lib->encoding->clear_cache(lib->encoding, this);
        free(this);
    }
}

// 从PEM/DER加载私钥
static gmssl_private_key_t *load(chunk_t blob, va_list args)
{
    private_gmssl_private_key_t *this;
    FILE *fp;
    
    INIT(this,
        .public = {
            .key = {
                .get_type = _get_type,
                .sign = _sign,
                .decrypt = _decrypt,
                .get_keysize = _get_keysize,
                .get_public_key = _get_public_key,
                .equals = private_key_equals,
                .belongs_to = private_key_belongs_to,
                .get_fingerprint = private_key_get_fingerprint,
                .has_fingerprint = private_key_has_fingerprint,
                .get_encoding = _get_encoding,
                .get_ref = _get_ref,
                .destroy = _destroy,
            },
        },
        .ref = 1,
    );
    
    // 使用GmSSL从PEM加载
    fp = fmemopen(blob.ptr, blob.len, "r");
    if (!fp || !SM2_private_key_from_pem(&this->key, fp))
    {
        DBG1(DBG_LIB, "failed to load SM2 private key");
        if (fp) fclose(fp);
        free(this);
        return NULL;
    }
    fclose(fp);
    
    return &this->public;
}

gmssl_private_key_t *gmssl_private_key_load(key_type_t type, va_list args)
{
    chunk_t blob = chunk_empty;
    
    if (type != KEY_SM2)
    {
        return NULL;
    }
    
    while (TRUE)
    {
        switch (va_arg(args, builder_part_t))
        {
            case BUILD_BLOB_ASN1_DER:
            case BUILD_BLOB_PEM:
                blob = va_arg(args, chunk_t);
                continue;
            case BUILD_END:
                break;
            default:
                return NULL;
        }
        break;
    }
    
    if (blob.ptr)
    {
        return load(blob, args);
    }
    return NULL;
}
```

#### 4.1.4 插件注册（gmssl_plugin.c）

```c
/*
 * GmSSL插件 - 国密算法支持
 */
#include "gmssl_plugin.h"
#include "gmssl_crypter.h"
#include "gmssl_hasher.h"
#include "gmssl_signer.h"
#include "gmssl_public_key.h"
#include "gmssl_private_key.h"

#include <library.h>

typedef struct private_gmssl_plugin_t private_gmssl_plugin_t;

struct private_gmssl_plugin_t {
    gmssl_plugin_t public;
};

METHOD(plugin_t, get_name, char*,
    private_gmssl_plugin_t *this)
{
    return "gmssl";
}

METHOD(plugin_t, get_features, int,
    private_gmssl_plugin_t *this, plugin_feature_t *features[])
{
    static plugin_feature_t f[] = {
        // SM4加密算法
        PLUGIN_REGISTER(CRYPTER, gmssl_crypter_create),
            PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_CBC, 16),
            PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_ECB, 16),
            PLUGIN_PROVIDE(CRYPTER, ENCR_SM4_CTR, 16),
            
        // SM3哈希算法
        PLUGIN_REGISTER(HASHER, gmssl_hasher_create),
            PLUGIN_PROVIDE(HASHER, HASH_SM3),
            
        // HMAC-SM3
        PLUGIN_REGISTER(SIGNER, gmssl_signer_create),
            PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_SM3_128),
            PLUGIN_PROVIDE(SIGNER, AUTH_HMAC_SM3_256),
            
        // PRF-HMAC-SM3
        PLUGIN_REGISTER(PRF, gmssl_prf_create),
            PLUGIN_PROVIDE(PRF, PRF_HMAC_SM3),
            
        // SM2公钥
        PLUGIN_REGISTER(PUBKEY, gmssl_public_key_load, TRUE),
            PLUGIN_PROVIDE(PUBKEY, KEY_SM2),
            PLUGIN_PROVIDE(PUBKEY_VERIFY, SIGN_SM2_WITH_SM3),
            PLUGIN_PROVIDE(PUBKEY_VERIFY, SIGN_SM2_WITH_NULL),
            
        // SM2私钥
        PLUGIN_REGISTER(PRIVKEY, gmssl_private_key_load, TRUE),
            PLUGIN_PROVIDE(PRIVKEY, KEY_SM2),
            PLUGIN_PROVIDE(PRIVKEY_SIGN, SIGN_SM2_WITH_SM3),
            PLUGIN_PROVIDE(PRIVKEY_SIGN, SIGN_SM2_WITH_NULL),
            
        // SM2密钥生成
        PLUGIN_REGISTER(PRIVKEY_GEN, gmssl_private_key_gen, FALSE),
            PLUGIN_PROVIDE(PRIVKEY_GEN, KEY_SM2),
    };
    *features = f;
    return countof(f);
}

METHOD(plugin_t, destroy, void,
    private_gmssl_plugin_t *this)
{
    free(this);
}

plugin_t *gmssl_plugin_create()
{
    private_gmssl_plugin_t *this;
    
    INIT(this,
        .public = {
            .plugin = {
                .get_name = _get_name,
                .get_features = _get_features,
                .destroy = _destroy,
            },
        },
    );
    
    DBG1(DBG_LIB, "GmSSL plugin loaded - SM2/SM3/SM4 support enabled");
    
    return &this->public.plugin;
}
```

### 4.2 配置文件修改

### 5.1 完整的国密IPsec配置

#### 5.1.1 IKE提案配置

**文件**：`/etc/swanctl/swanctl.conf`
```yaml
connections {
    gm-site-to-site {
        version = 2
        
        # IKE算法：SM4加密 + SM3完整性 + SM2密钥交换
        proposals = sm4-sm3-sm2dh
        
        # 重认证时间
        rekey_time = 3600s
        
        local_addrs = 192.168.1.1
        remote_addrs = 192.168.1.2
        
        local {
            auth = pubkey
            certs = server-sm2.pem
            id = "C=CN, O=MyCompany, CN=vpn-server"
        }
        
        remote {
            auth = pubkey
            id = "C=CN, O=MyCompany, CN=vpn-client"
        }
        
        children {
            gm-tunnel {
                # ESP算法：SM4-GCM（AEAD模式）
                esp_proposals = sm4gcm16-sm2dh
                
                # 或者使用传统模式
                # esp_proposals = sm4-sm3
                
                local_ts = 10.1.0.0/24
                remote_ts = 10.2.0.0/24
                
                # 自动启动
                start_action = trap
                
                # DPD检测
                dpd_action = restart
                
                rekey_time = 1800s
            }
        }
    }
}

# CA证书配置
authorities {
    gm-ca {
        cacert = ca-sm2.pem
    }
}

# 密钥配置
secrets {
    private {
        file = server-sm2-key.pem
    }
}
```

---

#### 5.1.1 服务端配置（192.168.1.1）

**文件**：`/etc/swanctl/swanctl.conf`
```yaml
connections {
    gm-site-to-site {
        version = 2
        proposals = sm4-sm3-sm2dh
        
        local_addrs = 192.168.1.2
        remote_addrs = 192.168.1.1
        
        local {
            auth = pubkey
            certs = client-sm2.pem
            id = "C=CN, O=MyCompany, CN=vpn-client"
        }
        
        remote {
            auth = pubkey
            id = "C=CN, O=MyCompany, CN=vpn-server"
        }
        
        children {
            gm-tunnel {
                esp_proposals = sm4gcm16-sm2dh
                local_ts = 10.2.0.0/24
                remote_ts = 10.1.0.0/24
                start_action = start  # 客户端主动发起
            }
        }
    }
}

authorities {
    gm-ca {
        cacert = ca-sm2.pem
    }
}

secrets {
    private {
        file = client-sm2-key.pem
    }
}
```

---

#### 5.1.2 客户端配置（192.168.1.2）

```bash
# 1. 生成CA私钥
pki --gen --type sm2 --outform pem > ca-sm2-key.pem

# 2. 生成自签名CA证书
pki --self --in ca-sm2-key.pem --type sm2 \
    --dn "C=CN, O=MyCompany, CN=MyCompany Root CA" \
    --ca --lifetime 3650 --outform pem > ca-sm2.pem

# 3. 生成服务器私钥
pki --gen --type sm2 --outform pem > server-sm2-key.pem

# 4. 生成服务器证书请求
pki --req --in server-sm2-key.pem --type sm2 \
    --dn "C=CN, O=MyCompany, CN=vpn-server" \
    --san vpn-server.example.com \
    --outform pem > server-sm2-req.pem

# 5. 签发服务器证书
pki --issue --in server-sm2-req.pem --type sm2 \
    --cacert ca-sm2.pem --cakey ca-sm2-key.pem \
    --dn "C=CN, O=MyCompany, CN=vpn-server" \
    --san vpn-server.example.com \
    --flag serverAuth --flag ikeIntermediate \
    --lifetime 1825 --outform pem > server-sm2.pem

# 6. 类似方式生成客户端证书
pki --gen --type sm2 --outform pem > client-sm2-key.pem
pki --req --in client-sm2-key.pem --type sm2 \
    --dn "C=CN, O=MyCompany, CN=vpn-client" \
    --outform pem > client-sm2-req.pem
pki --issue --in client-sm2-req.pem --type sm2 \
    --cacert ca-sm2.pem --cakey ca-sm2-key.pem \
    --dn "C=CN, O=MyCompany, CN=vpn-client" \
    --lifetime 1825 --outform pem > client-sm2.pem
```

**注意**：以上命令假设pki工具已经支持SM2，实际需要在代码中实现：
```c
// src/pki/commands/gen.c
// 需要添加对KEY_SM2的支持

// src/pki/commands/issue.c
// 需要添加对SIGN_SM2_WITH_SM3的支持
```

---

### 5.2 使用GmSSL生成SM2证书

**推荐使用GmSSL命令行工具生成国密证书**：

```bash
# 1. 生成CA私钥
gmssl sm2keygen -pass 1234 -out ca-sm2-key.pem -pubout ca-sm2-pub.pem

# 2. 生成自签名CA证书
gmssl reqsign \
    -key ca-sm2-key.pem -pass 1234 \
    -sm3 \
    -days 3650 \
    -subj "/C=CN/O=MyCompany/CN=MyCompany Root CA" \
    -out ca-sm2.pem

# 3. 生成服务器私钥
gmssl sm2keygen -pass 1234 -out server-sm2-key.pem -pubout server-sm2-pub.pem

# 4. 生成服务器证书请求
gmssl reqgen \
    -key server-sm2-key.pem -pass 1234 \
    -sm3 \
    -subj "/C=CN/O=MyCompany/CN=vpn-server" \
    -out server-sm2-req.pem

# 5. 用CA签发服务器证书
gmssl reqsign \
    -in server-sm2-req.pem \
    -cacert ca-sm2.pem \
    -key ca-sm2-key.pem -pass 1234 \
    -sm3 \
    -days 1825 \
    -out server-sm2.pem

# 6. 类似方式生成客户端证书
gmssl sm2keygen -pass 1234 -out client-sm2-key.pem
gmssl reqgen \
    -key client-sm2-key.pem -pass 1234 \
    -sm3 \
    -subj "/C=CN/O=MyCompany/CN=vpn-client" \
    -out client-sm2-req.pem
    
gmssl reqsign \
    -in client-sm2-req.pem \
    -cacert ca-sm2.pem \
    -key ca-sm2-key.pem -pass 1234 \
    -sm3 \
    -days 1825 \
    -out client-sm2.pem

# 7. 验证证书
gmssl certverify -in server-sm2.pem -cacert ca-sm2.pem
gmssl certparse -in server-sm2.pem
```

**或使用strongSwan PKI工具（需要先实现SM2支持）**：

### 5.2 备选：使用strongSwan PKI工具

```yaml
connections {
    hybrid-connection {
        version = 2
        
        # 提案列表：优先国密，回退到国际算法
        proposals = sm4-sm3-sm2dh,aes256-sha256-ecp256,aes128-sha256-modp2048
        
        local {
            auth = pubkey
            # 可以同时配置SM2和RSA证书
            certs = my-sm2-cert.pem,my-rsa-cert.pem
        }
        
        children {
            hybrid-child {
                # ESP也支持多个提案
                esp_proposals = sm4gcm16,aes256gcm16,aes256-sha256
            }
        }
    }
}
```

---

### 5.3 混合模式配置（国密+国际算法）

**修改**：`/etc/strongswan.conf`
```
charon {
    # 日志级别：0=silent, 1=audit, 2=control, 3=controlmore, 4=raw, -1=default
    filelog {
        /var/log/charon.log {
            time_format = %b %e %T
            ike_name = yes
            append = no
            default = 2
            ike = 3        # IKE协商详细日志
            cfg = 3        # 配置相关
            enc = 3        # 加密相关
            asn = 3        # ASN.1解析
        }
    }
}
```

### 5.4 调试和验证

#### 5.4.1 启用详细日志

```bash
# 加载配置
swanctl --load-all

# 发起连接
swanctl --initiate --child gm-tunnel

# 查看SA信息
swanctl --list-sas

# 输出示例：
# gm-site-to-site: #1, ESTABLISHED, IKEv2
#   local  'C=CN, O=MyCompany, CN=vpn-server' @ 192.168.1.1[4500]
#   remote 'C=CN, O=MyCompany, CN=vpn-client' @ 192.168.1.2[4500]
#   SM4_CBC/HMAC_SM3_128/PRF_HMAC_SM3/SM2_DH
#   established 10s ago, rekeying in 3590s
#   gm-tunnel: #1, reqid 1, INSTALLED, TUNNEL
#     installed 10s ago, rekeying in 1790s, expires in 1950s
#     in  c123456  10.2.0.0/24 === 10.1.0.0/24 out c789012
#     ESP/SM4_GCM_16/SM2_DH
```

#### 5.4.2 查看协商结果

```bash
# 抓取IKE和ESP数据包
tcpdump -i eth0 -n -s 0 -w gm-ipsec.pcap \
    '(udp port 500 or udp port 4500 or esp)'

# 使用Wireshark分析
# 注意：需要Wireshark支持国密算法解析
```

---

#### 5.4.3 抓包分析

```bash
# 测试SM4性能
ipsec bench --alg sm4 --size 1024 --times 10000

# 对比AES性能
ipsec bench --alg aes256 --size 1024 --times 10000

# 输出示例：
# SM4-CBC (128 bit):
#   size | time [s] | cycles/byte | cycles/block | mbytes/s
#   1024 |    0.156 |       48.92 |       783.7 |    6561.2
#
# AES-CBC-256:
#   size | time [s] | cycles/byte | cycles/block | mbytes/s
#   1024 |    0.142 |       44.53 |       712.5 |    7211.3
```

### 5.5 性能测试

#### 5.5.1 加密性能测试

```bash
# 在IPsec隧道上运行iperf3
# 服务端
iperf3 -s

# 客户端
iperf3 -c 10.1.0.10 -t 60 -i 5

# 输出会显示使用SM4加密的吞吐量
```

---

#### 5.5.2 吞吐量测试

**关键原则**：所有地方使用相同的枚举值

```c
// crypter.h中定义
ENCR_SM4_CBC = 1031

// 在所有使用的地方保持一致：
// - proposal_keywords_static.txt
// - crypter_names数组
// - switch-case语句
// - 插件注册
```

---

### 5.6 使用GmSSL的优势验证

编译并测试GmSSL插件：

```bash
# 1. 编译strongSwan with GmSSL支持
./autogen.sh
./configure --enable-gmssl --with-gmssl=/usr/local
make

# 2. 验证插件加载
ipsec listplugins | grep gmssl
# 输出应包含：
#   gmssl: loaded, features: CRYPTER:ENCR_SM4_CBC HASHER:HASH_SM3 ...

# 3. 测试SM4加密
ipsec bench --alg sm4 --size 1024 --times 10000

# 4. 测试SM3哈希
ipsec bench --alg sm3 --size 1024 --times 10000

# 5. 验证证书加载
ipsec pki --print --in server-sm2.pem
# 应正确显示SM2公钥信息
```

---

## 6. 使用GmSSL vs 自行实现的最终对比

### 6.1 开发效率对比

| 阶段 | 使用GmSSL | 自行实现 | 节省时间 |
|------|----------|---------|---------|
| 环境搭建 | 1天 | 1天 | 0天 |
| SM4实现 | 1天（适配层） | 5天（含算法） | 4天 |
| SM3实现 | 0.5天 | 3天 | 2.5天 |
| HMAC-SM3 | 0.5天 | 2天 | 1.5天 |
| SM2实现 | 3天 | 15天 | 12天 |
| 测试调试 | 3天 | 10天 | 7天 |
| **总计** | **9天** | **36天** | **27天 (75%)** |

### 6.2 代码质量对比

| 指标 | 使用GmSSL | 自行实现 |
|------|----------|---------|
| 代码行数 | ~1700行 | ~4200行 |
| Bug风险 | 低（仅适配层） | 高（算法实现复杂） |
| 性能 | 优秀（GmSSL优化） | 一般（需手动优化） |
| 安全性 | 高（已审计） | 未知（需审计） |
| 可维护性 | 高 | 中 |
| 合规认证 | 易 | 难 |

### 6.3 技术风险对比

| 风险类型 | 使用GmSSL | 自行实现 |
|---------|----------|---------|
| 算法错误 | ✅ 低风险 | ⚠️ 高风险 |
| 性能问题 | ✅ 低风险 | ⚠️ 中风险 |
| 安全漏洞 | ✅ 低风险 | ⚠️ 高风险 |
| 兼容性 | ✅ 低风险 | ⚠️ 中风险 |
| 维护成本 | ✅ 低 | ⚠️ 高 |

### 6.4 最终建议

**✅ 强烈推荐使用GmSSL方案**

**核心优势**：
1. **开发周期缩短75%**：从36天降至9天
2. **代码量减少60%**：从4200行降至1700行  
3. **质量保证**：使用经过国密局认证的实现
4. **零算法风险**：无需关心底层算法细节
5. **易于维护**：跟随GmSSL库更新即可

**实施建议**：
```
第1周: 安装GmSSL + 创建插件骨架
第2周: 实现SM4/SM3/HMAC-SM3适配层
第3周: 实现SM2公钥/私钥适配层
第4周: 集成测试 + Bug修复
第5周: 性能优化 + 文档完善
```

**参考资源**：
- GmSSL官网: http://gmssl.org/
- GmSSL GitHub: https://github.com/guanzhi/GmSSL
- GmSSL文档: http://gmssl.org/docs/
- strongSwan OpenSSL插件: `src/libstrongswan/plugins/openssl/`

---

## 7. 代码实现核心要点

### 7.1 算法标识符一致性

**SM4特点**：固定128位密钥

```c
METHOD(crypter_t, get_key_size, size_t,
    private_gmsm_crypter_t *this)
{
    // SM4始终返回16字节（128位）
    return 16;
}

METHOD(crypter_t, set_key, bool,
    private_gmsm_crypter_t *this, chunk_t key)
{
    // 严格检查密钥长度
    if (key.len != 16)
    {
        DBG1(DBG_LIB, "SM4 key must be 128 bits, got %d", key.len * 8);
        return FALSE;
    }
    
    // 密钥扩展
    sm4_key_schedule(key.ptr, this->round_keys);
    return TRUE;
}
```

---

### 7.2 密钥长度处理

**SM4分组大小**：16字节

```c
METHOD(crypter_t, get_iv_size, size_t,
    private_gmsm_crypter_t *this)
{
    switch (this->algorithm)
    {
        case ENCR_SM4_CBC:
        case ENCR_SM4_CTR:
            return 16;  // 128位IV
        case ENCR_SM4_GCM_ICV16:
            return 8;   // GCM模式使用8字节显式nonce
        default:
            return 0;
    }
}
```

---

### 7.3 IV/Nonce处理

**证书和签名算法OID**：

```c
// src/libstrongswan/asn1/oid.h
// 需要添加SM2/SM3相关OID

#define OID_SM2                    /* 1.2.156.10197.1.301 */
#define OID_SM3                    /* 1.2.156.10197.1.401 */
#define OID_SM2_WITH_SM3          /* 1.2.156.10197.1.501 */

// 在oid.c中实现映射
int signature_scheme_to_oid(signature_scheme_t scheme)
{
    switch (scheme)
    {
        case SIGN_SM2_WITH_SM3:
            return OID_SM2_WITH_SM3;
        // ...
    }
}
```

---

### 7.4 OID映射

| 层次 | 原算法 | 国密算法 | 难度 |
|------|--------|----------|------|
| **IKE加密** | AES-CBC | SM4-CBC | 中 |
| **IKE完整性** | HMAC-SHA256 | HMAC-SM3 | 低 |
| **IKE PRF** | PRF-HMAC-SHA256 | PRF-HMAC-SM3 | 低 |
| **IKE DH** | ECP-256 | SM2-DH | 高 |
| **ESP加密** | AES-GCM | SM4-GCM | 中 |
| **ESP完整性** | HMAC-SHA256 | HMAC-SM3 | 低 |
| **证书签名** | ECDSA-SHA256 | SM2-SM3 | 高 |
| **证书哈希** | SHA256 | SM3 | 低 |

## 8. 总结

### 8.1 关键对应关系

| 使用场景 | 代码位置 | 函数调用链 | 涉及的国密算法 |
|---------|---------|-----------|--------------|
| **IKE密钥派生** | `keymat_v2.c:240` | `derive_ike_keys()` → `create_prf(prf_alg)` → `create_kdf(KDF_PRF_PLUS)` → `allocate_bytes()` | PRF_HMAC_SM3 |
| **IKE消息加密** | `keymat_v2.c:285` | `create_ike_traditional()` → `create_crypter(enc_alg)` → `set_key()` → `encrypt()/decrypt()` | SM4-CBC |
| **IKE消息完整性** | `keymat_v2.c:297` | `create_ike_traditional()` → `create_signer(int_alg)` → `set_key()` → `get_signature()/verify_signature()` | HMAC-SM3-128 |
| **IKE消息AEAD** | `keymat_v2.c:312` | `create_ike_aead()` → `create_crypter(enc_alg)` → `encrypt()/decrypt()` (内置完整性) | SM4-GCM-16 |
| **身份认证签名** | `pubkey_authenticator.c:350` | `build()` → `select_signature_schemes()` → `private->sign(SIGN_SM2_WITH_SM3)` → SM2签名算法 | SM2 + SM3 |
| **身份认证验证** | `pubkey_authenticator.c:650` | `process()` → `parse_signature_auth_data()` → `public->verify(SIGN_SM2_WITH_SM3)` → SM2验证算法 | SM2 + SM3 |
| **证书链验证** | `x509_cert.c:1718` | `issued_by()` → `issuer->get_public_key()` → `key->verify(scheme)` → SM2验证算法 | SM2 + SM3 |
| **证书指纹** | `certificate.c` | `get_fingerprint()` → `create_hasher(HASH_SM3)` → `get_hash()` | SM3 |
| **ESP密钥派生** | `keymat_v2.c:540` | `derive_child_keys()` → `create_kdf(KDF_PRF_PLUS, prf_alg)` → `allocate_bytes()` | PRF_HMAC_SM3 |
| **ESP加密** | `esp_packet.c:289` | `encrypt()` → `aead->encrypt()` → `crypter->encrypt()` + `signer->get_signature()` | SM4 + HMAC-SM3 |
| **ESP解密** | `esp_packet.c:228` | `decrypt()` → `aead->decrypt()` → `signer->verify_signature()` + `crypter->decrypt()` | HMAC-SM3 + SM4 |

### 8.2 代码调用路径对照表

**Phase 1（核心功能）**：
1. ✅ SM4-CBC加密器
2. ✅ SM3哈希
3. ✅ HMAC-SM3签名器
4. ✅ 算法关键字注册

**Phase 2（证书支持）**：
5. ✅ SM2私钥/公钥
6. ✅ SM2签名/验证
7. ✅ X.509证书支持

**Phase 3（高级功能）**：
8. ⭕ SM4-GCM AEAD模式
9. ⭕ SM2密钥交换
10. ⭕ 性能优化

### 8.3 实施优先级

| 分类 | 修改类型 | 文件数量 | 预计代码行数 | 难度 |
|------|---------|---------|-------------|------|
| **枚举定义** | 添加常量 | 7个文件 | ~50行 | 低 |
| **算法实现** | 新增文件 | 6个文件 | ~2000行 | 高 |
| **工厂注册** | 修改逻辑 | 1个文件 | ~100行 | 中 |
| **OID映射** | 添加映射 | 2个文件 | ~50行 | 低 |
| **关键字** | 添加配置 | 1个文件 | ~20行 | 低 |
| **构建系统** | 配置修改 | 3个文件 | ~100行 | 低 |
| **测试代码** | 新增测试 | ~10个文件 | ~1000行 | 中 |
| **合计** | - | **~30个文件** | **~3300行** | - |

### 8.4 使用GmSSL的关键代码修改点统计

| 分类 | 修改类型 | 文件数量 | 代码行数（GmSSL方案） | 难度 |
|------|---------|---------|---------------------|------|
| **枚举定义** | 添加常量 | 7个文件 | ~50行 | 低 |
| **算法适配** | 新增文件（调用GmSSL） | 6个文件 | ~1200行 | 中 |
| **工厂注册** | 修改逻辑 | 1个文件 | ~100行 | 中 |
| **OID映射** | 添加映射 | 2个文件 | ~50行 | 低 |
| **关键字** | 添加配置 | 1个文件 | ~20行 | 低 |
| **构建系统** | 配置修改 | 3个文件 | ~150行 | 低 |
| **测试代码** | 新增测试 | ~10个文件 | ~500行 | 中 |
| **合计** | - | **~30个文件** | **~2070行** | - |

**对比自行实现**：
- 代码量减少：3300行 → 2070行（**减少37%**）
- 核心算法代码：2000行 → 0行（**100%由GmSSL提供**）
- 仅需编写适配层：~1200行

### 8.5 关键代码修改点统计（原方案）

- [ ] SM4加密/解密正确性（标准测试向量）
- [ ] SM3哈希正确性（标准测试向量）
- [ ] SM2签名/验证正确性
- [ ] IKE协商成功（使用国密算法）
- [ ] ESP隧道数据传输正常
- [ ] SM2证书加载和验证
- [ ] 混合模式（国密+国际算法）协商
- [ ] 性能达标（与AES对比）
- [ ] 与其他国密设备互通性

---

### 8.6 测试检查清单

```c
// 对称加密
ENCR_SM4_CBC = 1031
ENCR_SM4_GCM_ICV16 = 1034

// 哈希
HASH_SM3 = 1032

// 完整性
AUTH_HMAC_SM3_128 = 1032
AUTH_HMAC_SM3_256 = 1033

// PRF
PRF_HMAC_SM3 = 9  // 或使用私有编号

// 公钥
KEY_SM2 = 6
SIGN_SM2_WITH_SM3 = ?  // 待定义
```

## 附录A：快速参考

### A.1 算法枚举速查

```
# 加密算法
sm4, sm4cbc, sm4ctr, sm4gcm, sm4gcm16

# 完整性算法
sm3, hmac-sm3, sm3-128, sm3-256

# PRF（通常自动选择）
prfsm3, hmac-sm3

# DH组
sm2dh, sm2-256

# 组合提案
sm4-sm3, sm4-sm3-sm2dh, sm4gcm16-sm2dh
```

### A.2 配置关键字速查

```bash
# 查看支持的算法
ipsec listall

# 查看加载的插件
swanctl --stats

# 测试算法
ipsec bench --alg sm4

# 重新加载配置
swanctl --load-all

# 查看连接状态
swanctl --list-sas

# 查看证书
swanctl --list-certs
```

### A.3 常用命令
