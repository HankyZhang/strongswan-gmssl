# 算法提案（Proposal）详解

## 1. 什么是算法提案？

### 通俗解释

想象一下两个人要进行加密通信，他们需要先商量好：
- 用什么算法加密数据？（比如AES还是SM4）
- 用什么算法验证数据完整性？（比如HMAC-SHA256还是HMAC-SM3）
- 密钥交换用什么方法？（比如DH-2048还是SM2）

**算法提案**就像是一张"菜单"，列出了一套完整的加密方案。

### 现实类比

```
类比1：餐厅套餐
==================
提案1（豪华套餐）：
  - 主菜：牛排（AES-256）
  - 汤：龙虾汤（HMAC-SHA384）
  - 甜点：提拉米苏（PRF-HMAC-SHA384）
  - 饮料：红酒（DH-4096）

提案2（标准套餐）：
  - 主菜：鸡肉（AES-128）
  - 汤：蘑菇汤（HMAC-SHA256）
  - 甜点：布丁（PRF-HMAC-SHA256）
  - 饮料：果汁（DH-2048）

提案3（经济套餐）：
  - 主菜：鱼（3DES）
  - 汤：番茄汤（HMAC-SHA1）
  - 甜点：冰淇淋（PRF-HMAC-SHA1）
  - 饮料：水（DH-1536）

客户A：我想要提案1或提案2
客户B：我只提供提案2或提案3
结果：双方都支持提案2，选择提案2！
```

---

## 2. IKE提案的组成部分

### IKE（Internet Key Exchange）提案包含4种算法

```
┌─────────────────────────────────────────────────────────────┐
│              一个完整的IKE提案                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ① 加密算法 (ENCRYPTION_ALGORITHM)                          │
│     作用：保护IKE消息的机密性                                │
│     例如：AES-CBC-256, AES-CBC-128, 3DES, SM4-CBC           │
│                                                             │
│  ② 完整性算法 (INTEGRITY_ALGORITHM)                         │
│     作用：验证IKE消息没有被篡改                              │
│     例如：HMAC-SHA256, HMAC-SHA1, HMAC-SM3                  │
│                                                             │
│  ③ 伪随机函数 (PSEUDO_RANDOM_FUNCTION, PRF)                │
│     作用：生成密钥材料                                       │
│     例如：PRF-HMAC-SHA256, PRF-HMAC-SHA1, PRF-HMAC-SM3      │
│                                                             │
│  ④ 密钥交换方法 (KEY_EXCHANGE_METHOD)                       │
│     作用：在不安全信道上协商共享密钥                         │
│     例如：DH-2048, DH-4096, ECP-256, SM2                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 具体示例

```
提案示例1：AES256-SHA256-MODP2048
  ├─ 加密算法：AES-CBC，密钥长度256位
  ├─ 完整性算法：HMAC-SHA2-256-128（输出128位）
  ├─ PRF：PRF-HMAC-SHA2-256
  └─ 密钥交换：MODP-2048（2048位DH群）

提案示例2（国密）：SM4-SM3-SM2
  ├─ 加密算法：SM4-CBC，密钥长度128位
  ├─ 完整性算法：HMAC-SM3-128（输出128位）
  ├─ PRF：PRF-HMAC-SM3
  └─ 密钥交换：SM2（椭圆曲线）

提案示例3：AES128-SHA1-MODP1536
  ├─ 加密算法：AES-CBC，密钥长度128位
  ├─ 完整性算法：HMAC-SHA1-96（输出96位）
  ├─ PRF：PRF-HMAC-SHA1
  └─ 密钥交换：MODP-1536（1536位DH群）
```

---

## 3. ESP提案的组成部分

### ESP（Encapsulating Security Payload）提案

ESP用于保护实际的IP数据包，通常只需要2种算法：

```
┌─────────────────────────────────────────────────────────────┐
│              一个完整的ESP提案                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ① 加密算法 (ENCRYPTION_ALGORITHM)                          │
│     作用：加密IP数据包内容                                   │
│     例如：AES-CBC-256, AES-GCM-256, SM4-CBC                 │
│                                                             │
│  ② 完整性算法 (INTEGRITY_ALGORITHM) - 可选                  │
│     作用：验证数据包完整性（GCM等AEAD算法不需要）            │
│     例如：HMAC-SHA256, HMAC-SHA1, HMAC-SM3                  │
│                                                             │
│  ③ 扩展序列号 (ESN) - 可选                                  │
│     作用：支持更大的序列号空间（防重放）                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 具体示例

```
ESP提案示例1：AES256-SHA256
  ├─ 加密算法：AES-CBC-256
  └─ 完整性算法：HMAC-SHA2-256-128

ESP提案示例2（国密）：SM4-SM3
  ├─ 加密算法：SM4-CBC
  └─ 完整性算法：HMAC-SM3-128

ESP提案示例3（AEAD模式）：AES256-GCM
  └─ 加密算法：AES-GCM-256（自带完整性验证，不需要单独的HMAC）
```

---

## 4. 提案协商过程

### 完整的协商流程

```
第1步：发起方准备提案列表
========================
发起方（客户端）：
  我支持以下提案（按优先级排序）：
    提案1：AES256-SHA256-MODP2048  ← 最优先
    提案2：AES128-SHA256-MODP2048
    提案3：AES128-SHA1-MODP1536    ← 最低优先级
  
  ┌───────────────────────────────────┐
  │  IKE_SA_INIT 请求                 │
  ├───────────────────────────────────┤
  │  SA Payload:                      │
  │    Proposal 1: ...                │
  │    Proposal 2: ...                │
  │    Proposal 3: ...                │
  └───────────────────────────────────┘
           │
           │ 通过网络发送
           ↓


第2步：响应方选择提案
========================
响应方（服务器）：
  我的配置：
    提案A：AES256-SHA384-ECP256
    提案B：AES256-SHA256-MODP2048
    提案C：AES128-SHA1-MODP1024
  
  收到对方的3个提案，让我对比一下...
  
  比较过程：
  ┌─────────────────────────────────────────────────┐
  │ 我的提案A vs 对方提案1                          │
  │   AES256 == AES256 ✓                            │
  │   SHA384 != SHA256 ✗  ← 不匹配                  │
  │ 结论：不兼容                                     │
  └─────────────────────────────────────────────────┘
  
  ┌─────────────────────────────────────────────────┐
  │ 我的提案A vs 对方提案2                          │
  │   AES256 != AES128 ✗  ← 不匹配                  │
  │ 结论：不兼容                                     │
  └─────────────────────────────────────────────────┘
  
  ┌─────────────────────────────────────────────────┐
  │ 我的提案A vs 对方提案3                          │
  │   AES256 != AES128 ✗  ← 不匹配                  │
  │ 结论：不兼容                                     │
  └─────────────────────────────────────────────────┘
  
  ┌─────────────────────────────────────────────────┐
  │ 我的提案B vs 对方提案1                          │
  │   AES256 == AES256 ✓                            │
  │   SHA256 == SHA256 ✓                            │
  │   PRF-SHA256 == PRF-SHA256 ✓                    │
  │   MODP2048 == MODP2048 ✓                        │
  │ 结论：完全匹配！✓✓✓                             │
  └─────────────────────────────────────────────────┘
  
  选择：提案B / 对方提案1
  
  ┌───────────────────────────────────┐
  │  IKE_SA_INIT 响应                 │
  ├───────────────────────────────────┤
  │  SA Payload:                      │
  │    Proposal 1: AES256-SHA256-...  │
  │    (只返回选中的一个提案)          │
  └───────────────────────────────────┘
           │
           │ 通过网络发送
           ↓


第3步：发起方确认
========================
发起方：
  收到响应，对方选择了我的提案1
  很好，我们达成一致！
  
  ✓ 加密算法：AES-CBC-256
  ✓ 完整性算法：HMAC-SHA2-256-128
  ✓ PRF：PRF-HMAC-SHA2-256
  ✓ 密钥交换：MODP-2048
  
  现在开始使用这些算法进行密钥交换...
```

---

## 5. 配置文件中的提案

### strongSwan配置示例（传统算法）

```bash
# /etc/swanctl/swanctl.conf

connections {
    myvpn {
        # IKE提案配置
        proposals = aes256-sha256-modp2048,aes128-sha256-modp2048,aes128-sha1-modp1536
        #           ^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^
        #           提案1（优先）            提案2（次选）            提案3（备选）
        
        children {
            mytunnel {
                # ESP提案配置
                esp_proposals = aes256-sha256,aes128-sha256,aes128-sha1
                #               ^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^
                #               ESP提案1       ESP提案2       ESP提案3
            }
        }
    }
}
```

### 国密算法配置示例（修改后）

```bash
# /etc/swanctl/swanctl.conf

connections {
    gm_vpn {
        # IKE提案配置（国密优先，兼容传统算法）
        proposals = sm4-sm3-sm2,aes256-sha256-modp2048
        #           ^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^
        #           国密提案     传统提案（备选）
        
        children {
            gm_tunnel {
                # ESP提案配置（国密优先）
                esp_proposals = sm4-sm3,aes256-sha256
                #               ^^^^^^^ ^^^^^^^^^^^^^
                #               国密     传统（备选）
            }
        }
    }
}
```

---

## 6. 提案选择的策略

### 策略1：优先本地配置（默认）

```
本地配置：[提案A, 提案B, 提案C]
对端发送：[提案X, 提案Y, 提案Z]

匹配顺序：
  1. 提案A vs 提案X → 不匹配
  2. 提案A vs 提案Y → 不匹配
  3. 提案A vs 提案Z → 不匹配
  4. 提案B vs 提案X → 匹配！✓

选择：提案B

优势：确保使用本地优先的算法
```

### 策略2：优先对端提案（PROPOSAL_PREFER_SUPPLIED）

```
本地配置：[提案A, 提案B, 提案C]
对端发送：[提案X, 提案Y, 提案Z]

匹配顺序：
  1. 提案X vs 提案A → 不匹配
  2. 提案X vs 提案B → 不匹配
  3. 提案X vs 提案C → 不匹配
  4. 提案Y vs 提案A → 不匹配
  5. 提案Y vs 提案B → 匹配！✓

选择：提案Y

优势：尊重对端的优先级，适用于客户端场景
```

---

## 7. 提案协商失败的场景

### 场景1：完全不兼容

```
发起方：
  proposals = sm4-sm3-sm2
  (只支持国密算法)

响应方：
  proposals = aes256-sha256-modp2048,aes128-sha1-modp1536
  (只支持传统算法)

结果：
  ✗ 没有任何共同的算法
  ✗ 协商失败
  ✗ IKE连接建立失败

错误日志：
  no matching proposal found
  configured proposals: IKE:SM4_CBC_128/HMAC_SM3_128/PRF_HMAC_SM3/SM2
  received proposals: IKE:AES_CBC_256/HMAC_SHA2_256_128/PRF_HMAC_SHA2_256/MODP_2048
```

### 场景2：部分算法不匹配

```
发起方：
  proposals = aes256-sha256-modp4096

响应方：
  proposals = aes256-sha256-modp2048

比较：
  ✓ 加密：AES256 == AES256
  ✓ 完整性：SHA256 == SHA256
  ✓ PRF：PRF-SHA256 == PRF-SHA256
  ✗ 密钥交换：MODP4096 != MODP2048  ← 不匹配

结果：
  ✗ 提案不匹配（需要所有算法都一致）
  ✗ 协商失败
```

### 场景3：成功降级

```
发起方：
  proposals = sm4-sm3-sm2,aes256-sha256-modp2048,aes128-sha1-modp1536

响应方：
  proposals = aes128-sha1-modp1536,aes256-sha256-modp2048

比较：
  提案1(sm4-sm3-sm2) vs 提案A(aes128-sha1-modp1536) → ✗
  提案1(sm4-sm3-sm2) vs 提案B(aes256-sha256-modp2048) → ✗
  提案2(aes256-sha256-modp2048) vs 提案A(...) → ✗
  提案2(aes256-sha256-modp2048) vs 提案B(aes256-sha256-modp2048) → ✓

结果：
  ✓ 选择 aes256-sha256-modp2048
  ✓ 虽然不是最优（国密），但可以工作
  ⚠ 这就是"降级"：从首选算法降到备选算法
```

---

## 8. 为什么需要多个提案？

### 原因1：兼容性

```
场景：企业VPN服务器需要支持多种客户端

服务器配置：
  proposals = sm4-sm3-sm2,aes256-sha256-modp2048,aes128-sha1-modp1536
  
客户端A（国产设备，支持国密）：
  proposals = sm4-sm3-sm2
  → 选择：sm4-sm3-sm2 ✓

客户端B（Windows，不支持国密）：
  proposals = aes256-sha256-modp2048,aes128-sha1-modp1536
  → 选择：aes256-sha256-modp2048 ✓

客户端C（老旧设备）：
  proposals = aes128-sha1-modp1536
  → 选择：aes128-sha1-modp1536 ✓

所有客户端都能连接！
```

### 原因2：安全性和性能平衡

```
提案列表（按安全性排序）：
  1. sm4-sm3-sm2         ← 国密，最安全（符合国家标准）
  2. aes256-sha384-modp4096  ← 高安全性（但速度较慢）
  3. aes256-sha256-modp2048  ← 标准安全性（平衡）
  4. aes128-sha256-modp2048  ← 较低安全性（速度快）

优先使用最安全的，但如果对端不支持，可以降级到次优方案。
```

### 原因3：平滑升级

```
场景：从传统算法迁移到国密算法

阶段1（初期）：
  proposals = aes256-sha256-modp2048,sm4-sm3-sm2
  # 传统算法优先，国密作为备选

阶段2（过渡期）：
  proposals = sm4-sm3-sm2,aes256-sha256-modp2048
  # 国密优先，传统算法作为兼容

阶段3（完成）：
  proposals = sm4-sm3-sm2
  # 仅国密，不再支持传统算法
```

---

## 9. 提案在代码中的表示

### proposal_t 数据结构

```c
struct proposal_t {
    // 协议类型
    protocol_id_t protocol;  // PROTO_IKE 或 PROTO_ESP
    
    // 提案编号
    uint8_t number;  // 1, 2, 3, ...
    
    // SPI（安全参数索引）
    uint64_t spi;
    
    // 内部存储的算法列表
    // 实际是一个哈希表，key=算法类型，value=算法列表
    /*
    例如：
    {
        ENCRYPTION_ALGORITHM: [
            {algo: ENCR_AES_CBC, key_size: 256},
            {algo: ENCR_AES_CBC, key_size: 128}
        ],
        INTEGRITY_ALGORITHM: [
            {algo: AUTH_HMAC_SHA2_256_128, key_size: 0}
        ],
        PSEUDO_RANDOM_FUNCTION: [
            {algo: PRF_HMAC_SHA2_256, key_size: 0}
        ],
        KEY_EXCHANGE_METHOD: [
            {algo: MODP_2048, key_size: 0}
        ]
    }
    */
};
```

### 提案字符串解析

```
输入字符串：
  "aes256-sha256-modp2048"

解析过程：
  1. 分割字符串（按'-'分隔）
     → ["aes256", "sha256", "modp2048"]
  
  2. 识别每个部分
     "aes256" → 加密算法
       ├─ 算法：ENCR_AES_CBC
       └─ 密钥长度：256位
     
     "sha256" → 完整性算法和PRF
       ├─ 完整性：AUTH_HMAC_SHA2_256_128
       └─ PRF：PRF_HMAC_SHA2_256
     
     "modp2048" → 密钥交换
       └─ 方法：MODP_2048
  
  3. 创建proposal_t对象
     proposal->add_algorithm(proposal, ENCRYPTION_ALGORITHM, 
                            ENCR_AES_CBC, 256);
     proposal->add_algorithm(proposal, INTEGRITY_ALGORITHM, 
                            AUTH_HMAC_SHA2_256_128, 0);
     proposal->add_algorithm(proposal, PSEUDO_RANDOM_FUNCTION, 
                            PRF_HMAC_SHA2_256, 0);
     proposal->add_algorithm(proposal, KEY_EXCHANGE_METHOD, 
                            MODP_2048, 0);
```

---

## 10. 总结

### 核心概念

```
┌────────────────────────────────────────────────────────────┐
│  算法提案 = 一套完整的加密方案                              │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  IKE提案 = 加密 + 完整性 + PRF + 密钥交换                   │
│  ESP提案 = 加密 + 完整性                                   │
│                                                            │
│  提案列表 = [首选提案, 次选提案, 备选提案, ...]            │
│                                                            │
│  提案协商 = 找到双方都支持的提案                            │
│                                                            │
│  协商成功 → 使用选中的算法建立安全连接                      │
│  协商失败 → 无法建立连接                                   │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

### 关键要点

1. **提案是一个整体**：所有算法必须完全匹配才算成功
2. **优先级很重要**：提案列表的顺序决定了优先使用哪个
3. **兼容性靠多提案**：配置多个提案以支持不同的对端
4. **协商是双向的**：双方都必须支持才能成功
5. **失败要有备选**：如果没有备选提案，连接会失败

### 实际应用

```
场景：部署国密VPN

正确配置：
  proposals = sm4-sm3-sm2,aes256-sha256-modp2048
  
  ✓ 国产设备：使用sm4-sm3-sm2
  ✓ 国外设备：使用aes256-sha256-modp2048
  ✓ 所有设备都能连接

错误配置：
  proposals = sm4-sm3-sm2
  
  ✓ 国产设备：使用sm4-sm3-sm2
  ✗ 国外设备：无法连接（不支持国密）
  ✗ 部分设备无法工作
```

希望这个详细解释能帮助您理解算法提案的概念！
